# 1. Проектирование на основе объектов

> **Примечание**: Слово "дизайн" в русском и английском языках может иметь разные значения. В русском языке оно чаще всего воспринимается как оформление внешнего вида, тогда как в английском, особенно в контексте программирования, оно может также означать "проектирование."

В разработке программного обеспечения проектирование часто рассматривается как шаг, предшествующий программированию. Однако это не совсем верно; на практике анализ, программирование и проектирование пересекаются, комбинируются и переплетаются. В этой книге мы будем затрагивать одновременно вопросы проектирования и программирования, не пытаясь разделять их на отдельные категории. Одним из преимуществ языка Python является возможность ясно выразить проектирование.

В этой главе мы поговорим о том, как можно пройти путь от хорошей идеи к написанию программы. Мы создадим некоторые артефакты проектирования — такие как диаграммы, — которые помогут нам прояснить наши мысли до начала написания кода. 

> **Примечание**: Термин "артефакты" в данном контексте обозначает результаты проектировочной работы, такие как диаграммы и документы. Это специальные материалы, которые помогают в разработке, не путать с привычным значением слова "артефакт."

Мы рассмотрим следующие темы:
- Что означает объектно-ориентированность
- Разница между объектно-ориентированным проектированием и объектно-ориентированным программированием
- Основные принципы объектно-ориентированного проектирования
- Основы унифицированного языка моделирования (UML) и когда его использование не является излишним

Мы также введем практический пример проектирования для этой книги, используя модель архитектурного представления "4+1".

> **Примечание**: "Практический пример" (case study) — это метод представления проектирования или разработки, основанный на использовании реального или условного примера задачи.

В этом разделе мы затронем следующие вопросы:
- Обзор классической задачи машинного обучения — известной проблемы классификации Ирисов

> **Примечание**: "Классификатор" (classifier) в данном случае обозначает алгоритм машинного обучения, способный относить объекты к определенным классам или категориям. В данной задаче "классификатор" используется для определения типа ириса на основе его характеристик.

- Общий контекст обработки для этого классификатора
- Набросок двух представлений иерархии классов, которые, по-видимому, будут адекватны для решения задачи

> **Примечание**: "Иерархия классов" (class hierarchy) представляет собой структуру, описывающую, как классы связаны между собой. Это помогает организовать классы в системе, особенно в объектно-ориентированном проектировании.

Таким образом, эта глава даст базовое представление о переходе от идеи к проектированию программы, используя язык Python и базовые принципы объектно-ориентированного подхода.

# Введение в объектно-ориентированный подход

Все знают, что такое объект: это материальная вещь, которую можно ощутить, потрогать и использовать. Первые объекты, с которыми мы взаимодействуем, как правило, — это игрушки младенцев. Деревянные кубики, пластиковые фигуры и крупные детали головоломок являются первыми знакомыми объектами. Младенцы быстро понимают, что разные объекты выполняют разные действия: колокольчики звенят, кнопки нажимаются, рычаги тянутся.

Определение объекта в разработке программного обеспечения не сильно отличается. Программные объекты не являются материальными предметами, которые можно взять в руки или почувствовать, но они представляют собой модели чего-то, что может выполнять определённые действия и на что можно воздействовать. Формально объект — это совокупность данных и связанных с ними действий.

Когда мы говорим об объекте, что означает объектно-ориентированный подход? Согласно словарю, "ориентированный" означает "направленный на". Объектно-ориентированное программирование (англ. Object-Oriented Programming, OOP) означает написание кода, направленного на моделирование объектов. Это один из многих методов описания действий сложных систем. Он подразумевает описание взаимодействующих объектов через их данные и поведение.

Если вы знакомы с популярными концепциями, то, вероятно, встречали такие термины, как объектно-ориентированный анализ (англ. Object-Oriented Analysis, OOA), объектно-ориентированное проектирование (англ. Object-Oriented Design, OOD), объектно-ориентированный анализ и проектирование (англ. Object-Oriented Analysis and Design, OOAD) и объектно-ориентированное программирование (OOP). Все они связаны с общей объектно-ориентированной концепцией.

На самом деле, анализ, проектирование и программирование — это все этапы разработки программного обеспечения. Определение их как "объектно-ориентированных" указывает на конкретный подход к разработке.

**Объектно-ориентированный анализ (OOA)** — это процесс анализа задачи, системы или задачи, которую кто-то хочет превратить в работающую программу, с целью выявления объектов и взаимодействий между ними. Этап анализа посвящён определению того, что необходимо сделать.

Результатом этапа анализа является описание системы, часто в форме требований. Если бы мы завершили этап анализа за один шаг, то превратили бы задачу, такую как *«Как ботаник, я нуждаюсь в сайте, который поможет пользователям классифицировать растения для их правильного определения»*, в набор необходимых функций. Примером могут быть следующие требования, описывающие действия, которые должен выполнить посетитель сайта. Каждый элемент является действием, связанным с объектом; действия выделены курсивом, а объекты — жирным шрифтом:

- *Просмотр* **Предыдущих загрузок**
- *Загрузка* **новых известных примеров**
- *Тестирование* на **качество**
- *Просмотр* **товаров**
- *Просмотр* **рекомендаций**

> **Примечание**: На самом деле, термин "анализ" здесь может быть немного вводящим в заблуждение. Младенец, о котором мы говорили ранее, не анализирует кубики и детали головоломки. Скорее, он исследует свою среду, манипулирует формами и пробует, подходят ли они друг к другу. Возможно, более подходящим термином здесь было бы "объектно-ориентированное исследование". В разработке программного обеспечения начальные этапы анализа включают интервьюирование клиентов, изучение их процессов и устранение ненужных вариантов.

**Объектно-ориентированное проектирование (OOD)** — это процесс преобразования таких требований в спецификацию реализации. Проектировщик должен дать названия объектам, определить их поведение и формально указать, какие объекты могут запускать определенные действия на других объектах. Этап проектирования направлен на то, чтобы превратить *что нужно сделать* в *как это должно быть сделано*.

Результатом этапа проектирования является спецификация реализации. Если бы мы завершили этап проектирования за один шаг, то превратили бы требования, определённые в ходе объектно-ориентированного анализа, в набор классов и интерфейсов, которые могли бы быть реализованы (в идеале) в любом объектно-ориентированном языке программирования.

**Объектно-ориентированное программирование (OOP)** — это процесс преобразования проекта в работающую программу, которая выполняет то, что изначально запросил заказчик.

Конечно, в идеальном мире мы могли бы следовать этим этапам один за другим, в идеальном порядке, как советуют классические учебники. Однако в реальности всё гораздо сложнее. Каким бы тщательным ни был процесс разделения этих этапов, всегда остаются моменты, которые нуждаются в дополнительном анализе на этапе проектирования, а при программировании обнаруживаются особенности, требующие уточнений в проекте.

Большинство методов разработки программного обеспечения XXI века признаёт, что этот каскадный (или "водопадный") процесс не всегда работает. Более эффективной оказывается итеративная модель разработки. В итеративной разработке небольшая часть задачи моделируется, проектируется и программируется, после чего продукт пересматривается и расширяется для улучшения каждой функции и добавления новых в серии коротких циклов разработки.

Остальная часть этой книги посвящена объектно-ориентированному программированию, но в этой главе мы рассмотрим основные принципы объектно-ориентированного подхода в контексте проектирования. Это позволит нам понять концепции без необходимости отвлекаться на синтаксис языка или сообщения об ошибках Python.

# Объекты и классы

Объект — это совокупность данных с связанным с ними поведением. Как мы можем отличить одни типы объектов от других? Например, яблоки и апельсины — это оба объекта, но, как говорится, "их нельзя сравнивать". В программировании компьютеров яблоки и апельсины редко моделируются, но представим, что мы создаём приложение для инвентаризации на фруктовой ферме. В рамках этого примера мы предположим, что яблоки хранятся в бочках, а апельсины — в корзинах.

На данный момент наша предметная область включает четыре типа объектов: яблоки, апельсины, корзины и бочки. В объектно-ориентированном моделировании термин, используемый для обозначения типа объекта, — это "класс". Таким образом, с технической точки зрения у нас теперь есть четыре класса объектов.

Важно понимать разницу между объектом и классом. Классы описывают связанные объекты. Они подобны чертежам для создания объекта. Перед вами может находиться три апельсина. Каждый апельсин — это отдельный объект, но у всех трёх есть атрибуты и поведение, связанные с одним классом: общим классом апельсинов.

> **Примечание**: В объектно-ориентированном проектировании часто используется Унифицированный язык моделирования (англ. Unified Modeling Language, UML). UML помогает визуально представлять отношения между классами, используя диаграммы классов. Эти диаграммы позволяют программистам легко и наглядно передавать информацию о структуре проекта.

Связь между четырьмя классами объектов в нашей системе инвентаризации можно описать с помощью диаграммы классов на языке UML (UML — это английская аббревиатура от Unified Modeling Language, поскольку трёхбуквенные аббревиатуры никогда не выходят из моды). Вот наша первая диаграмма классов:

**Рисунок 1.1: Диаграмма классов**

Эта диаграмма показывает, что экземпляры класса **Orange** (обычно называемые "апельсины") как-то связаны с **Basket**, а экземпляры класса **Apple** ("яблоки") связаны с **Barrel**. Связь (association) — это самый простой способ, которым экземпляры двух классов могут быть связаны.

Синтаксис диаграмм UML в целом довольно очевиден; вам не нужно изучать учебник, чтобы (в основном) понять, что происходит, глядя на такую диаграмму. UML также довольно легко рисовать, и он интуитивно понятен. Ведь многие, описывая классы и их связи, естественно рисуют прямоугольники с линиями между ними. Наличие стандарта, основанного на таких интуитивных диаграммах, упрощает общение между программистами, проектировщиками, менеджерами и членами команды.

Обратите внимание, что диаграмма UML обычно изображает определения классов, но мы описываем атрибуты объектов. Диаграмма показывает класс **Apple** и класс **Barrel**, указывая, что конкретное яблоко находится в определенной бочке. Хотя UML можно использовать для отображения отдельных объектов, это редко бывает необходимо. Изображение классов даёт достаточно информации об объектах, являющихся экземплярами каждого класса.

Некоторые программисты относятся к UML скептически, считая его пустой тратой времени. Указывая на итеративную разработку, они утверждают, что формальные спецификации, оформленные в виде сложных диаграмм UML, станут устаревшими ещё до их реализации, а поддержка этих формальных диаграмм будет лишь напрасной тратой времени и никому не принесет пользы.

Тем не менее, любая команда, состоящая более чем из одного человека, рано или поздно должна будет обсудить детали создаваемых компонентов. UML крайне полезен для обеспечения быстрого, лёгкого и последовательного общения. Даже те организации, которые пренебрегают формальными диаграммами классов, часто используют неформальную версию UML на совещаниях по проектированию или в командных обсуждениях.

Более того, самый важный человек, с которым вам придётся общаться, — это вы сами в будущем. Мы все думаем, что сможем вспомнить принятые решения по проектированию, но всегда бывают моменты "Зачем я это сделал?" в будущем. Если мы сохраним черновые схемы, сделанные в начале проектирования, они в конечном итоге станут полезной справкой.

Эта глава, однако, не предназначена как учебник по UML. Таких учебников много в интернете, а также существует множество книг на эту тему. UML охватывает не только диаграммы классов и объектов; у него также есть синтаксис для случаев использования, развертывания, изменений состояния и активностей. Мы рассмотрим некоторые общие элементы синтаксиса диаграмм классов в рамках обсуждения объектно-ориентированного проектирования. Вы сможете освоить структуру на примерах и неосознанно начнёте использовать синтаксис, вдохновлённый UML, в своих командных или личных заметках по проектированию.

Наша начальная диаграмма, хотя и корректна, не напоминает нам, что яблоки хранятся в бочках и сколько бочек может вместить одно яблоко. Она просто показывает, что яблоки как-то связаны с бочками. Ассоциация между классами часто очевидна и не нуждается в дополнительном пояснении, но у нас есть возможность добавлять дополнительные уточнения по мере необходимости.

> **Примечание**: Одним из преимуществ UML является то, что большинство элементов в нем являются опциональными. Мы указываем в диаграмме только ту информацию, которая имеет смысл в текущей ситуации. На быстрой сессии на доске можно просто начертить линии между прямоугольниками. В формальном документе можно пойти в детали.

В случае с яблоками и бочками можно предположить, что связь означает, что в одну бочку можно положить несколько яблок. Однако, чтобы не возникло путаницы с тем, что "одно яблоко портит одну бочку", мы можем улучшить диаграмму, как показано здесь:

**Рисунок 1.2: Диаграмма классов с дополнительными деталями**

Эта диаграмма показывает, что апельсины хранятся в корзинах, и добавлена стрелка, указывающая, что помещается куда. Она также указывает количество объектов, которые могут быть задействованы в связи с обеих сторон ассоциации. Одна **Basket** может содержать много (обозначено символом *) объектов **Orange**. Любой объект **Orange** может находиться ровно в одной **Basket**. Это количество называется **мощностью (multiplicity)** объекта. Этот термин также можно встретить под названием **кардинальность (cardinality)**. Можно представить себе кардинальность как определённое число или диапазон, тогда как мощность понимается как обобщенное "больше чем один экземпляр".

> **Примечание**: Иногда бывает трудно вспомнить, какое число мощности должно находиться на каком конце линии связи. Мощность, ближайшая к классу, указывает количество объектов этого класса, которые могут быть связаны с любым одним объектом на другом конце связи. Для ассоциации "яблоки в бочках", читая слева направо, многие экземпляры класса **Apple** (то есть много объектов **Apple**) могут находиться в одной бочке. Читая справа налево, ровно одна **Barrel** может быть связана с любым одним **Apple**.

Мы рассмотрели основы классов и то, как они задают отношения между объектами. Теперь нам нужно обсудить атрибуты, которые определяют состояние объекта, и поведение объекта, которое может включать изменение состояния или взаимодействие с другими объектами.