# 1. Проектирование на основе объектов

> **Примечание**: Слово "дизайн" в русском и английском языках может иметь разные значения. В русском языке оно чаще всего воспринимается как оформление внешнего вида, тогда как в английском, особенно в контексте программирования, оно может также означать "проектирование."

В разработке программного обеспечения проектирование часто рассматривается как шаг, предшествующий программированию. Однако это не совсем верно; на практике анализ, программирование и проектирование пересекаются, комбинируются и переплетаются. В этой книге мы будем затрагивать одновременно вопросы проектирования и программирования, не пытаясь разделять их на отдельные категории. Одним из преимуществ языка Python является возможность ясно выразить проектирование.

В этой главе мы поговорим о том, как можно пройти путь от хорошей идеи к написанию программы. Мы создадим некоторые артефакты проектирования — такие как диаграммы, — которые помогут нам прояснить наши мысли до начала написания кода. 

> **Примечание**: Термин "артефакты" в данном контексте обозначает результаты проектировочной работы, такие как диаграммы и документы. Это специальные материалы, которые помогают в разработке, не путать с привычным значением слова "артефакт."

Мы рассмотрим следующие темы:
- Что означает объектно-ориентированность
- Разница между объектно-ориентированным проектированием и объектно-ориентированным программированием
- Основные принципы объектно-ориентированного проектирования
- Основы унифицированного языка моделирования (UML) и когда его использование не является излишним

Мы также введем практический пример проектирования для этой книги, используя модель архитектурного представления "4+1".

> **Примечание**: "Практический пример" (case study) — это метод представления проектирования или разработки, основанный на использовании реального или условного примера задачи.

В этом разделе мы затронем следующие вопросы:
- Обзор классической задачи машинного обучения — известной проблемы классификации Ирисов

> **Примечание**: "Классификатор" (classifier) в данном случае обозначает алгоритм машинного обучения, способный относить объекты к определенным классам или категориям. В данной задаче "классификатор" используется для определения типа ириса на основе его характеристик.

- Общий контекст обработки для этого классификатора
- Набросок двух представлений иерархии классов, которые, по-видимому, будут адекватны для решения задачи

> **Примечание**: "Иерархия классов" (class hierarchy) представляет собой структуру, описывающую, как классы связаны между собой. Это помогает организовать классы в системе, особенно в объектно-ориентированном проектировании.

Таким образом, эта глава даст базовое представление о переходе от идеи к проектированию программы, используя язык Python и базовые принципы объектно-ориентированного подхода.

# Введение в объектно-ориентированный подход

Все знают, что такое объект: это материальная вещь, которую можно ощутить, потрогать и использовать. Первые объекты, с которыми мы взаимодействуем, как правило, — это игрушки младенцев. Деревянные кубики, пластиковые фигуры и крупные детали головоломок являются первыми знакомыми объектами. Младенцы быстро понимают, что разные объекты выполняют разные действия: колокольчики звенят, кнопки нажимаются, рычаги тянутся.

Определение объекта в разработке программного обеспечения не сильно отличается. Программные объекты не являются материальными предметами, которые можно взять в руки или почувствовать, но они представляют собой модели чего-то, что может выполнять определённые действия и на что можно воздействовать. Формально объект — это совокупность данных и связанных с ними действий.

Когда мы говорим об объекте, что означает объектно-ориентированный подход? Согласно словарю, "ориентированный" означает "направленный на". Объектно-ориентированное программирование (англ. Object-Oriented Programming, OOP) означает написание кода, направленного на моделирование объектов. Это один из многих методов описания действий сложных систем. Он подразумевает описание взаимодействующих объектов через их данные и поведение.

Если вы знакомы с популярными концепциями, то, вероятно, встречали такие термины, как объектно-ориентированный анализ (англ. Object-Oriented Analysis, OOA), объектно-ориентированное проектирование (англ. Object-Oriented Design, OOD), объектно-ориентированный анализ и проектирование (англ. Object-Oriented Analysis and Design, OOAD) и объектно-ориентированное программирование (OOP). Все они связаны с общей объектно-ориентированной концепцией.

На самом деле, анализ, проектирование и программирование — это все этапы разработки программного обеспечения. Определение их как "объектно-ориентированных" указывает на конкретный подход к разработке.

**Объектно-ориентированный анализ (OOA)** — это процесс анализа задачи, системы или задачи, которую кто-то хочет превратить в работающую программу, с целью выявления объектов и взаимодействий между ними. Этап анализа посвящён определению того, что необходимо сделать.

Результатом этапа анализа является описание системы, часто в форме требований. Если бы мы завершили этап анализа за один шаг, то превратили бы задачу, такую как *«Как ботаник, я нуждаюсь в сайте, который поможет пользователям классифицировать растения для их правильного определения»*, в набор необходимых функций. Примером могут быть следующие требования, описывающие действия, которые должен выполнить посетитель сайта. Каждый элемент является действием, связанным с объектом; действия выделены курсивом, а объекты — жирным шрифтом:

- *Просмотр* **Предыдущих загрузок**
- *Загрузка* **новых известных примеров**
- *Тестирование* на **качество**
- *Просмотр* **товаров**
- *Просмотр* **рекомендаций**

> **Примечание**: На самом деле, термин "анализ" здесь может быть немного вводящим в заблуждение. Младенец, о котором мы говорили ранее, не анализирует кубики и детали головоломки. Скорее, он исследует свою среду, манипулирует формами и пробует, подходят ли они друг к другу. Возможно, более подходящим термином здесь было бы "объектно-ориентированное исследование". В разработке программного обеспечения начальные этапы анализа включают интервьюирование клиентов, изучение их процессов и устранение ненужных вариантов.

**Объектно-ориентированное проектирование (OOD)** — это процесс преобразования таких требований в спецификацию реализации. Проектировщик должен дать названия объектам, определить их поведение и формально указать, какие объекты могут запускать определенные действия на других объектах. Этап проектирования направлен на то, чтобы превратить *что нужно сделать* в *как это должно быть сделано*.

Результатом этапа проектирования является спецификация реализации. Если бы мы завершили этап проектирования за один шаг, то превратили бы требования, определённые в ходе объектно-ориентированного анализа, в набор классов и интерфейсов, которые могли бы быть реализованы (в идеале) в любом объектно-ориентированном языке программирования.

**Объектно-ориентированное программирование (OOP)** — это процесс преобразования проекта в работающую программу, которая выполняет то, что изначально запросил заказчик.

Конечно, в идеальном мире мы могли бы следовать этим этапам один за другим, в идеальном порядке, как советуют классические учебники. Однако в реальности всё гораздо сложнее. Каким бы тщательным ни был процесс разделения этих этапов, всегда остаются моменты, которые нуждаются в дополнительном анализе на этапе проектирования, а при программировании обнаруживаются особенности, требующие уточнений в проекте.

Большинство методов разработки программного обеспечения XXI века признаёт, что этот каскадный (или "водопадный") процесс не всегда работает. Более эффективной оказывается итеративная модель разработки. В итеративной разработке небольшая часть задачи моделируется, проектируется и программируется, после чего продукт пересматривается и расширяется для улучшения каждой функции и добавления новых в серии коротких циклов разработки.

Остальная часть этой книги посвящена объектно-ориентированному программированию, но в этой главе мы рассмотрим основные принципы объектно-ориентированного подхода в контексте проектирования. Это позволит нам понять концепции без необходимости отвлекаться на синтаксис языка или сообщения об ошибках Python.

# Объекты и классы

Объект — это совокупность данных с связанным с ними поведением. Как мы можем отличить одни типы объектов от других? Например, яблоки и апельсины — это оба объекта, но, как говорится, "их нельзя сравнивать". В программировании компьютеров яблоки и апельсины редко моделируются, но представим, что мы создаём приложение для инвентаризации на фруктовой ферме. В рамках этого примера мы предположим, что яблоки хранятся в бочках, а апельсины — в корзинах.

На данный момент наша предметная область включает четыре типа объектов: яблоки, апельсины, корзины и бочки. В объектно-ориентированном моделировании термин, используемый для обозначения типа объекта, — это "класс". Таким образом, с технической точки зрения у нас теперь есть четыре класса объектов.

Важно понимать разницу между объектом и классом. Классы описывают связанные объекты. Они подобны чертежам для создания объекта. Перед вами может находиться три апельсина. Каждый апельсин — это отдельный объект, но у всех трёх есть атрибуты и поведение, связанные с одним классом: общим классом апельсинов.

> **Примечание**: В объектно-ориентированном проектировании часто используется Унифицированный язык моделирования (англ. Unified Modeling Language, UML). UML помогает визуально представлять отношения между классами, используя диаграммы классов. Эти диаграммы позволяют программистам легко и наглядно передавать информацию о структуре проекта.

Связь между четырьмя классами объектов в нашей системе инвентаризации можно описать с помощью диаграммы классов на языке UML (UML — это английская аббревиатура от Unified Modeling Language, поскольку трёхбуквенные аббревиатуры никогда не выходят из моды). Вот наша первая диаграмма классов:

**Рисунок 1.1: Диаграмма классов**

Эта диаграмма показывает, что экземпляры класса **Orange** (обычно называемые "апельсины") как-то связаны с **Basket**, а экземпляры класса **Apple** ("яблоки") связаны с **Barrel**. Связь (association) — это самый простой способ, которым экземпляры двух классов могут быть связаны.

Синтаксис диаграмм UML в целом довольно очевиден; вам не нужно изучать учебник, чтобы (в основном) понять, что происходит, глядя на такую диаграмму. UML также довольно легко рисовать, и он интуитивно понятен. Ведь многие, описывая классы и их связи, естественно рисуют прямоугольники с линиями между ними. Наличие стандарта, основанного на таких интуитивных диаграммах, упрощает общение между программистами, проектировщиками, менеджерами и членами команды.

Обратите внимание, что диаграмма UML обычно изображает определения классов, но мы описываем атрибуты объектов. Диаграмма показывает класс **Apple** и класс **Barrel**, указывая, что конкретное яблоко находится в определенной бочке. Хотя UML можно использовать для отображения отдельных объектов, это редко бывает необходимо. Изображение классов даёт достаточно информации об объектах, являющихся экземплярами каждого класса.

Некоторые программисты относятся к UML скептически, считая его пустой тратой времени. Указывая на итеративную разработку, они утверждают, что формальные спецификации, оформленные в виде сложных диаграмм UML, станут устаревшими ещё до их реализации, а поддержка этих формальных диаграмм будет лишь напрасной тратой времени и никому не принесет пользы.

Тем не менее, любая команда, состоящая более чем из одного человека, рано или поздно должна будет обсудить детали создаваемых компонентов. UML крайне полезен для обеспечения быстрого, лёгкого и последовательного общения. Даже те организации, которые пренебрегают формальными диаграммами классов, часто используют неформальную версию UML на совещаниях по проектированию или в командных обсуждениях.

Более того, самый важный человек, с которым вам придётся общаться, — это вы сами в будущем. Мы все думаем, что сможем вспомнить принятые решения по проектированию, но всегда бывают моменты "Зачем я это сделал?" в будущем. Если мы сохраним черновые схемы, сделанные в начале проектирования, они в конечном итоге станут полезной справкой.

Эта глава, однако, не предназначена как учебник по UML. Таких учебников много в интернете, а также существует множество книг на эту тему. UML охватывает не только диаграммы классов и объектов; у него также есть синтаксис для случаев использования, развертывания, изменений состояния и активностей. Мы рассмотрим некоторые общие элементы синтаксиса диаграмм классов в рамках обсуждения объектно-ориентированного проектирования. Вы сможете освоить структуру на примерах и неосознанно начнёте использовать синтаксис, вдохновлённый UML, в своих командных или личных заметках по проектированию.

Наша начальная диаграмма, хотя и корректна, не напоминает нам, что яблоки хранятся в бочках и сколько бочек может вместить одно яблоко. Она просто показывает, что яблоки как-то связаны с бочками. Ассоциация между классами часто очевидна и не нуждается в дополнительном пояснении, но у нас есть возможность добавлять дополнительные уточнения по мере необходимости.


> **Примечание**: Одним из преимуществ UML является то, что большинство элементов в нем являются опциональными. Мы указываем в диаграмме только ту информацию, которая имеет смысл в текущей ситуации. На быстрой сессии на доске можно просто начертить линии между прямоугольниками. В формальном документе можно пойти в детали.

В случае с яблоками и бочками можно предположить, что связь означает, что в одну бочку можно положить несколько яблок. Однако, чтобы не возникло путаницы с тем, что "одно яблоко портит одну бочку", мы можем улучшить диаграмму, как показано здесь:

**Рисунок 1.2: Диаграмма классов с дополнительными деталями**

Эта диаграмма показывает, что апельсины хранятся в корзинах, и добавлена стрелка, указывающая, что помещается куда. Она также указывает количество объектов, которые могут быть задействованы в связи с обеих сторон ассоциации. Одна **Basket** может содержать много (обозначено символом *) объектов **Orange**. Любой объект **Orange** может находиться ровно в одной **Basket**. Это количество называется **мощностью (multiplicity)** объекта. Этот термин также можно встретить под названием **кардинальность (cardinality)**. Можно представить себе кардинальность как определённое число или диапазон, тогда как мощность понимается как обобщенное "больше чем один экземпляр".

> **Примечание**: Иногда бывает трудно вспомнить, какое число мощности должно находиться на каком конце линии связи. Мощность, ближайшая к классу, указывает количество объектов этого класса, которые могут быть связаны с любым одним объектом на другом конце связи. Для ассоциации "яблоки в бочках", читая слева направо, многие экземпляры класса **Apple** (то есть много объектов **Apple**) могут находиться в одной бочке. Читая справа налево, ровно одна **Barrel** может быть связана с любым одним **Apple**.

Мы рассмотрели основы классов и то, как они задают отношения между объектами. Теперь нам нужно обсудить атрибуты, которые определяют состояние объекта, и поведение объекта, которое может включать изменение состояния или взаимодействие с другими объектами.


# Определение атрибутов и поведения

Теперь у нас есть представление об основных терминах объектно-ориентированного подхода. Объекты — это экземпляры классов, которые могут быть связаны друг с другом. Экземпляр класса — это конкретный объект с собственным набором данных и поведения; например, определённый апельсин на столе перед нами является экземпляром общего класса апельсинов.

> **Примечание**: Термин "экземпляр" в данном контексте обозначает отдельный объект, созданный на основе класса. Каждый экземпляр уникален, но обладает общими характеристиками с другими экземплярами того же класса.

У апельсина есть состояние, например, он может быть спелым или зелёным; мы задаём состояние объекта с помощью значений конкретных **атрибутов**.

> **Примечание**: Атрибуты объекта — это свойства, которые определяют его состояние. Они представляют собой данные, хранящиеся внутри объекта, и описывают его характеристики, такие как цвет, размер или степень зрелости в случае с апельсином.

Кроме того, у апельсина есть поведение. Сами по себе апельсины обычно пассивны. Изменения состояния накладываются на них извне. Давайте более подробно рассмотрим значения этих двух понятий — состояние и поведение.

> **Примечание**: В объектно-ориентированном программировании **поведение** объекта относится к действиям, которые он может выполнять, или к действиям, которые могут быть выполнены с ним.


## Данные описывают состояние объекта

Начнём с данных. Данные представляют собой отдельные характеристики конкретного объекта; его текущее состояние. Класс может определять конкретные наборы характеристик, которые являются частью всех объектов, входящих в этот класс. Любой конкретный объект может иметь разные значения данных для данных характеристик. Например, три апельсина на нашем столе (если мы ещё не съели ни одного) могут иметь разный вес. У класса апельсинов может быть атрибут **вес**, чтобы представлять этот параметр. Все экземпляры класса апельсинов имеют атрибут веса, но у каждого апельсина это значение может быть разным. Однако атрибуты не обязаны быть уникальными; два апельсина могут иметь одинаковый вес.

> **Примечание**: Термин "атрибуты" часто также называют "членами" или "свойствами". Некоторые авторы предполагают, что эти термины имеют разные значения, например, что атрибуты можно изменять, в то время как свойства могут быть только для чтения. В языке Python свойство можно определить как доступное только для чтения, но его значение всё равно будет основываться на атрибутах, которые, в конечном счёте, можно изменить, что делает концепцию "только для чтения" практически неактуальной. В этой книге мы будем использовать термины "атрибут" и "свойство" взаимозаменяемо. Кроме того, как мы обсудим в Главе 5, "Когда использовать объектно-ориентированное программирование", ключевое слово `property` имеет особое значение в Python для определённого типа атрибута.

В Python атрибут можно также называть **переменной экземпляра**. Это помогает уточнить, как работают атрибуты. Они представляют собой переменные с уникальными значениями для каждого экземпляра класса.

> **Примечание**: "Переменная экземпляра" в Python — это атрибут, который хранит данные, уникальные для каждого экземпляра конкретного класса. Такие переменные создаются в каждом новом объекте класса, что позволяет хранить индивидуальные значения для каждого объекта.

В нашем приложении для инвентаризации фруктов фермер может захотеть узнать, из какого сада пришел апельсин, когда его собрали и сколько он весит. Возможно, фермер также захочет отслеживать, где хранится каждая корзина. Яблоки могут иметь атрибут цвета, а бочки — быть разных размеров.

Некоторые из этих свойств могут принадлежать нескольким классам (мы можем захотеть узнать, когда были собраны и яблоки), но для нашего первого примера добавим несколько различных атрибутов в нашу диаграмму классов:

**Рисунок 1.3: Диаграмма классов с атрибутами**

В зависимости от того, насколько детализированным должно быть наше проектирование, мы также можем указать тип значения для каждого атрибута. В UML типы атрибутов часто представлены общими именами, понятными в большинстве языков программирования, например, целое число, число с плавающей точкой, строка, байт или логическое значение (Boolean). Однако типы могут также представлять общие коллекции, такие как списки, деревья или графы, или, что более важно, специфические для приложения классы.

> **Примечание**: На этапе проектирования UML может пересекаться с программированием, так как может возникнуть необходимость указать, какой тип данных будет использоваться. Основные примитивы и встроенные коллекции в одном языке программирования могут отличаться от других. Например, Java предлагает такие структуры, как `LinkedList` или `ArrayList`, тогда как в Python можно использовать `List[Apple]` в качестве подсказки типа и встроенный тип `list` для реализации.

Вот версия диаграммы с использованием (в основном) Python-специфичных подсказок типов:

**Рисунок 1.4: Диаграмма классов с атрибутами и их типами**

Обычно на этапе проектирования не требуется слишком много думать о типах данных, так как детали, связанные с реализацией, выбираются на этапе программирования. Общие названия типов обычно достаточно для проектирования; именно поэтому мы включили `date` как указатель на тип данных в Python, например, `datetime.datetime`. Если в проекте нужен тип контейнера "список", разработчики на Java могут выбрать `LinkedList` или `ArrayList`, а программисты на Python (то есть мы) могут использовать `List[Apple]` в качестве подсказки типа и тип `list` для реализации.

В нашем примере с фруктовой фермой все наши атрибуты являются простыми примитивами. Однако существуют некоторые **неявные атрибуты**, которые можно сделать явными — это связи (ассоциации). Для конкретного апельсина у нас есть атрибут, указывающий на корзину, в которой он хранится, — атрибут **basket** с подсказкой типа `Basket`.

> **Примечание**: В контексте объектно-ориентированного программирования (ООП) **связь** и **ассоциация** — это термины, описывающие отношения между объектами.
>
> - **Связь** — это общее понятие, которое описывает любые отношения между объектами или классами. Связи показывают, как один объект или класс зависит от другого, взаимодействует с ним или использует его. В UML связи обычно изображаются линиями, соединяющими классы.
> 
> - **Ассоциация** — это более конкретный вид связи, представляющий постоянные отношения между объектами. Ассоциация указывает на то, что один объект знает о существовании другого и может с ним взаимодействовать. Например, ассоциация может указывать, что один объект "владеет" другим или "использует" его, и такие связи часто имеют смысл в реальной жизни. В UML ассоциация также изображается линией, соединяющей классы, но иногда сопровождается указанием направленности или описанием отношений (например, "имеет", "содержит" или "включает").
> 
> Ассоциация бывает однонаправленной и двунаправленной. В однонаправленной ассоциации один объект знает о другом, а в двунаправленной — оба объекта знают друг о друге.


> **Примечание**: "Связь" между объектами может быть представлена в виде атрибута, описывающего отношение между экземплярами классов. Например, атрибут `basket` указывает, в какой именно корзине находится данный апельсин.

## Поведение — это действия

Теперь, когда мы знаем, как данные определяют состояние объекта, последний нераскрытый термин, на который нам нужно обратить внимание, — это **поведение**. Поведение — это действия, которые могут выполняться над объектом. Поведение, которое может быть выполнено с определённым классом объектов, выражается в виде **методов** этого класса.

> **Примечание**: В объектно-ориентированном программировании **методы** — это функции, принадлежащие классу, которые имеют доступ к атрибутам объекта, особенно к переменным экземпляра, связанным с данными этого объекта. В отличие от функций в структурированном программировании, методы могут обращаться к состоянию конкретного экземпляра, что позволяет им выполнять действия, связанные именно с этим объектом.

На уровне программирования методы похожи на функции, но они имеют доступ к атрибутам — в частности, к переменным экземпляра, содержащим данные, связанные с этим объектом. Как и функции, методы могут принимать параметры и возвращать значения.

Параметры метода передаются ему в виде набора объектов, которые необходимо передать в метод. Конкретные экземпляры объектов, передаваемые в метод во время его вызова, обычно называются **аргументами**.

> **Примечание**: Параметры — это переменные, объявленные в определении метода, в которые во время вызова метода передаются конкретные объекты — аргументы.

Эти объекты связываются с переменными параметров в теле метода. Метод использует их для выполнения своего поведения или задачи. Возвращаемые значения являются результатом выполнения этой задачи. Внутренние изменения состояния также являются возможным результатом выполнения метода.

Мы уже расширили наш пример с яблоками и апельсинами, превратив его в основное (хотя и надуманное) приложение для инвентаризации. Давайте немного усложним его и посмотрим, не выйдет ли оно из-под контроля. Одним из действий, связанных с апельсинами, может быть действие **сбора** (pick). Если подумать об его реализации, сбор потребует выполнения двух задач:

- Поместить апельсин в корзину, обновив атрибут **Basket** апельсина.
- Добавить апельсин в список **Orange** данной корзины.

Таким образом, методу **pick** необходимо знать, с какой корзиной он работает. Мы делаем это, передавая корзину в качестве параметра метода **pick**. Поскольку наш фермер также продает сок, мы можем добавить метод **squeeze** (выжать) в класс **Orange**. При вызове метод **squeeze** может возвращать количество полученного сока, одновременно удаляя **Orange** из корзины, в которой он находился.

> **Примечание**: В объектно-ориентированном подходе передача параметров позволяет методам использовать другие объекты или данные для выполнения своих задач. В данном случае, передавая параметр **Basket** в метод **pick**, мы указываем корзину, с которой взаимодействует апельсин, добавляя гибкость и точность в наши операции.

Класс **Basket** может иметь действие **sell** (продать). Когда корзина продаётся, наша система инвентаризации может обновить некоторые данные на пока неопределённых объектах для расчётов учёта и прибыли. С другой стороны, корзина с апельсинами может испортиться, прежде чем её успеют продать, поэтому мы добавляем метод **discard** (выбросить). Добавим эти методы в нашу диаграмму:

**Рисунок 1.5: Диаграмма классов с атрибутами и методами**

Добавление атрибутов и методов к отдельным объектам позволяет нам создать систему взаимодействующих объектов. Каждый объект в системе принадлежит определённому классу. Эти классы определяют, какие типы данных может содержать объект и какие методы могут быть вызваны. Данные в каждом объекте могут находиться в разном состоянии по сравнению с другими экземплярами того же класса; каждый объект может по-разному реагировать на вызов методов из-за различий в состоянии.

Объектно-ориентированный анализ и проектирование посвящены тому, чтобы понять, какими должны быть эти объекты и как они должны взаимодействовать. Каждый класс имеет **ответственности** и **сотрудничество**.

> **Примечание**: Ответственности — это задачи, которые должны выполнять объекты каждого класса, а сотрудничество — это взаимодействие между классами. Определение этих аспектов является важной частью объектно-ориентированного проектирования.

Следующий раздел описывает принципы, которые можно использовать для того, чтобы сделать взаимодействия как можно более простыми и интуитивными.

Обратите внимание, что продажа корзины не обязательно является функцией класса **Basket**. Возможно, что некоторый другой класс (не показанный на диаграмме) "заботится" о различных корзинах и их местонахождении. В нашем проекте часто будут встречаться границы, определяющие области ответственности для разных классов. Иногда распределение обязанностей между классами может быть неочевидным, что заставит нас пересматривать (и перерисовывать) наши UML-диаграммы более одного раза, чтобы исследовать альтернативные варианты проектирования.

> **Примечание**: Определение границ ответственности — одна из сложных задач в объектно-ориентированном проектировании. Иногда это требует итеративного подхода, при котором несколько вариантов схемы разрабатываются и анализируются, чтобы найти наиболее удачное распределение обязанностей между классами.


# Сокрытие деталей и создание публичного интерфейса

Основная цель моделирования объекта в объектно-ориентированном проектировании — определить, каким будет публичный интерфейс этого объекта. **Интерфейс** — это набор атрибутов и методов, которые могут быть доступны другим объектам для взаимодействия с данным объектом. Другим объектам не нужно (а в некоторых языках даже не разрешается) иметь доступ к внутренней работе объекта.

> **Примечание**: Под **публичным интерфейсом** понимается тот набор методов и атрибутов, который доступен для взаимодействия другим объектам, не раскрывая при этом внутренние механизмы работы объекта. Публичный интерфейс позволяет контролировать, какие данные и поведение доступны извне.

Пример из реального мира — это телевизор. Наш интерфейс к телевизору — это пульт управления. Каждая кнопка на пульте представляет метод, который можно вызвать у объекта **телевизор**. Когда мы, как вызывающий объект, используем эти методы, нас не интересует, получает ли телевизор сигнал по кабелю, через спутниковую антенну или через интернет-устройство. Мы не заботимся о том, какие электронные сигналы посылаются для регулировки громкости или предназначен ли звук для динамиков или наушников. Если мы откроем телевизор, чтобы получить доступ к его внутренним компонентам, например, чтобы разделить сигнал между внешними динамиками и наушниками, то можем потерять гарантию.

Этот процесс скрытия реализации объекта называется **сокрытием информации**. Иногда его называют **инкапсуляцией**, но инкапсуляция — это более широкое понятие. Инкапсулированные данные не обязательно скрыты. Инкапсуляция буквально означает создание "капсулы" или оболочки вокруг атрибутов. Корпус телевизора инкапсулирует его состояние и поведение. Мы имеем доступ к внешнему экрану, динамикам и пульту, но не имеем прямого доступа к проводам усилителей или приёмникам внутри корпуса телевизора.

> **Примечание**: Сокрытие информации — это процесс, ограничивающий доступ к внутренней реализации объекта, чтобы внешние объекты могли взаимодействовать только через публичный интерфейс. Инкапсуляция охватывает этот процесс, но также включает концепцию обёртывания состояния и поведения в единое целое.

Когда мы покупаем комплексную аудиосистему, уровень инкапсуляции меняется, поскольку мы получаем доступ к интерфейсам между компонентами. Если мы занимаемся разработкой устройств для Интернета вещей, мы можем разобрать устройство на части и нарушить попытку производителя скрыть детали его реализации.

Различие между инкапсуляцией и сокрытием информации в основном несущественно, особенно на уровне проектирования. Многие практические источники используют эти термины взаимозаменяемо. Как программистам на Python, нам фактически не нужно и не требуется скрывать информацию с помощью полностью частных, недоступных переменных (причины этого мы обсудим в Главе 2, "Объекты в Python"), поэтому более широкое определение инкапсуляции является подходящим.

Публичный интерфейс, однако, очень важен. Его необходимо тщательно проектировать, так как его изменение может быть сложным, если от него зависят другие классы. Изменение интерфейса может нарушить работу любых клиентских объектов, которые на него полагаются. Мы можем изменить внутреннюю реализацию по своему усмотрению, например, чтобы сделать её более эффективной или чтобы получить доступ к данным как по сети, так и локально, и клиентские объекты всё равно смогут с ним взаимодействовать, не изменяясь, используя публичный интерфейс. С другой стороны, если мы изменим интерфейс, изменив публичные имена атрибутов или порядок и типы аргументов, которые может принимать метод, все клиентские классы также придётся изменить. Проектируя публичный интерфейс, придерживайтесь простоты. Всегда разрабатывайте интерфейс объекта, основываясь на его удобстве в использовании, а не на сложности его кодирования (этот совет также применим к пользовательским интерфейсам).

> **Примечание**: В Python переменные, начинающиеся с подчёркивания (`_`), сигнализируют, что они не являются частью публичного интерфейса. Этот символ подчёркивания является предупреждением для других программистов, что такие переменные лучше не использовать вне класса.

Помните, что объекты программы могут представлять реальные объекты, но это не делает их реальными. Они являются моделями. Одно из важнейших преимуществ моделирования — это возможность игнорировать несущественные детали. Модель автомобиля, которую один из авторов собрал в детстве, снаружи выглядела как настоящий Thunderbird 1956 года, но, конечно, она не могла ездить. Когда автор был слишком мал, чтобы водить машину, эти детали были слишком сложными и несущественными. Модель — это абстракция реальной концепции.

> **Примечание**: **Абстракция** — это ещё один термин, связанный с инкапсуляцией и сокрытием информации. Абстракция означает работу с уровнем деталей, наиболее подходящим для выполнения конкретной задачи. Это процесс выделения публичного интерфейса из внутренних деталей.

Для водителя автомобиля абстракция включает взаимодействие с рулем, педалью акселератора и тормозами. Работу двигателя, трансмиссии и тормозной системы водитель не видит. Механик, напротив, работает на другом уровне абстракции, регулируя двигатель и обслуживая тормоза. Вот пример двух уровней абстракции для автомобиля:

**Рисунок 1.6: Уровни абстракции для автомобиля**

Теперь у нас есть несколько новых терминов, которые обозначают похожие концепции. Давайте кратко подытожим: абстракция — это процесс инкапсуляции информации с помощью отдельного публичного интерфейса. Любые частные элементы могут быть скрыты, что и составляет сокрытие информации. В UML-диаграммах можно использовать символ `-` вместо `+`, чтобы показать, что элемент не является частью публичного интерфейса.

Главный урок, который следует извлечь из всех этих определений, — это сделать наши модели понятными для других объектов, которые должны с ними взаимодействовать. Это означает уделение особого внимания деталям.

Убедитесь, что методы и свойства имеют осмысленные названия. При анализе системы объекты обычно представляют собой существительные в исходной задаче, в то время как методы — это обычно глаголы. Атрибуты могут быть прилагательными или дополнительными существительными. Давайте названия вашим классам, атрибутам и методам в соответствии с этим правилом.

Проектируя интерфейс, представьте, что вы сами являетесь этим объектом; вам нужны чёткие определения ваших обязанностей, и вы предпочитаете максимально возможную приватность для выполнения этих обязанностей. Не позволяйте другим объектам получать доступ к вашим данным, если вы не считаете, что это в ваших интересах. Не предоставляйте им интерфейс для выполнения определенной задачи, если вы не уверены, что это именно ваша обязанность.


# Композиция

До сих пор мы научились проектировать системы как группу взаимодействующих объектов, где каждое взаимодействие подразумевает рассмотрение объектов на соответствующем уровне абстракции. Однако мы ещё не знаем, как создать эти уровни абстракции. Существует несколько способов достижения этой цели; некоторые продвинутые шаблоны проектирования мы обсудим в главах 10, 11 и 12. Но даже большинство шаблонов проектирования опираются на два основных принципа объектно-ориентированного программирования, известных как **композиция** и **наследование**. Композиция проще, поэтому начнём с неё.

**Композиция** — это объединение нескольких объектов для создания нового. Композиция обычно является хорошим выбором, когда один объект является частью другого объекта.

> **Примечание**: Композиция позволяет создавать объекты, объединяя их компоненты. Это позволяет создавать иерархии и уровни абстракции, предоставляя более высокоуровневые интерфейсы для различных пользователей и позволяя скрывать детали внутреннего устройства.

Мы уже видели первый намёк на композицию, когда говорили об автомобилях. Автомобиль с двигателем внутреннего сгорания состоит из двигателя, трансмиссии, стартера, фар и лобового стекла, наряду с множеством других деталей. В свою очередь, двигатель состоит из поршней, коленчатого вала и клапанов. В этом примере композиция — хороший способ создания уровней абстракции. Объект **автомобиль** может предоставлять интерфейс, необходимый водителю, одновременно предоставляя доступ к его компонентам, что обеспечивает более глубокий уровень абстракции, подходящий для механика. Эти компоненты могут быть, конечно, далее разделены на ещё более мелкие детали, если механику потребуется больше информации для диагностики проблемы или настройки двигателя.

Автомобиль — это распространённый начальный пример композиции, но он не слишком полезен при проектировании компьютерных систем. Физические объекты легко разделить на составные части. Люди делают это с древности, ещё со времён греков, которые считали, что атомы — это мельчайшие частицы материи (у них, конечно, не было доступа к ускорителям частиц). В компьютерных системах, однако, определение составных объектов не происходит так же естественно, как с реальными клапанами и поршнями.

Объекты в объектно-ориентированной системе иногда представляют физические объекты, такие как люди, книги или телефоны. Однако чаще они представляют собой концепции. Люди имеют имена, книги имеют названия, а телефоны используются для совершения звонков. Звонки, названия, учётные записи, имена, встречи и платежи не всегда воспринимаются как объекты в физическом мире, но они часто моделируются как компоненты в компьютерных системах.

Давайте попробуем смоделировать более компьютерно-ориентированный пример, чтобы увидеть композицию в действии. Мы рассмотрим проектирование компьютерной игры в шахматы. Это было очень популярное развлечение в 80-х и 90-х годах. Люди предсказывали, что компьютеры однажды смогут обыграть шахматного мастера. Когда это произошло в 1997 году (компьютер IBM Deep Blue победил чемпиона мира по шахматам Гарри Каспарова), интерес к шахматной задаче поубавился. В наши дни потомки Deep Blue всегда выигрывают.

Шахматная партия играется между двумя игроками, используя шахматный набор с доской, состоящей из 64 позиций в сетке 8×8. На доске можно разместить два набора из 16 фигур, которые могут двигаться, поочередно делая ходы двумя игроками разными способами. Каждая фигура может брать другие фигуры. После каждого хода доска должна отображаться на экране компьютера.

> **Примечание**: Мы выделили некоторые из возможных объектов в описании курсивом, а несколько ключевых методов — жирным шрифтом. Это распространённый первый шаг при превращении объектно-ориентированного анализа в проектирование.

На этом этапе, чтобы подчеркнуть композицию, мы сосредоточимся на доске, не вдаваясь в детали игроков и различных типов фигур.

Начнем с самого высокого уровня абстракции. У нас есть два игрока, взаимодействующих с шахматным набором, поочередно совершая ходы:

**Рисунок 1.7: Диаграмма объектов/экземпляров для шахматной игры**

Это выглядит не совсем так, как наши предыдущие диаграммы классов, и это хорошо, потому что это не она! Это **диаграмма объектов**, также называемая **диаграммой экземпляров**. Она описывает систему в определённом состоянии времени и отображает конкретные экземпляры объектов, а не взаимодействие между классами. Помните, что оба игрока принадлежат к одному классу, поэтому диаграмма классов выглядит немного иначе:

**Рисунок 1.8: Диаграмма классов для шахматной игры**

Эта диаграмма показывает, что ровно два игрока могут взаимодействовать с одним шахматным набором. Она также указывает, что любой игрок может играть только с одним шахматным набором одновременно. Однако мы обсуждаем композицию, а не UML, поэтому давайте подумаем, из чего состоит шахматный набор. Нам не важно, из чего состоит игрок на данный момент. Мы можем предположить, что у него есть сердце и мозг, наряду с другими органами, но это не имеет значения для нашей модели. На самом деле, ничто не мешает представить игрока в виде самого Deep Blue, у которого нет ни сердца, ни мозга.

Шахматный набор, таким образом, состоит из доски и 32 фигур. Доска, в свою очередь, состоит из 64 позиций. Можно утверждать, что эти фигуры не являются частью шахматного набора, так как их можно заменить на другой набор фигур. Хотя это маловероятно или невозможно в компьютерной версии шахмат, этот момент подводит нас к понятию **агрегации**.

> **Примечание**: **Агрегация** почти идентична композиции. Различие заключается в том, что агрегированные объекты могут существовать независимо. Например, позицию нельзя связать с другой шахматной доской, поэтому мы говорим, что доска состоит из позиций. Однако фигуры, которые могут существовать отдельно от шахматного набора, находятся с ним в агрегатной связи.

Другой способ отличить агрегацию от композиции — это рассмотреть продолжительность существования объекта:
- Если внешний (составной) объект управляет созданием и уничтожением связанных (внутренних) объектов, композиция будет наиболее подходящей.
- Если связанный объект создается независимо от составного объекта или может пережить его, агрегатная связь более уместна.

> **Примечание**: Также важно помнить, что композиция является разновидностью агрегации; агрегация — это более общий вид композиции. Любая композиционная связь также является агрегатной, но не наоборот.

Опишем текущую композицию шахматного набора и добавим атрибуты к объектам, чтобы отразить их составные связи:

**Рисунок 1.9: Диаграмма классов для шахматной игры**

Композиционная связь представлена в UML как сплошной ромб. Пустой ромб представляет агрегатную связь. Вы заметите, что доска и фигуры хранятся как часть шахматного набора точно так же, как ссылка на них хранится как атрибут в шахматном наборе. Это показывает, что, как и в других случаях, на практике различие между агрегацией и композицией часто не имеет значения, как только вы перейдете от стадии проектирования к реализации. При реализации они ведут себя практически одинаково.

Это различие может помочь вам отличить их друг от друга, когда ваша команда обсуждает, как взаимодействуют разные объекты. Часто вам нужно различать их, когда речь идет о продолжительности существования связанных объектов. В большинстве случаев удаление составного объекта (например, доски) приведёт к удалению всех его позиций. Агрегированные объекты, однако, не удаляются автоматически.


# Наследование

Мы обсудили три типа отношений между объектами: ассоциацию, композицию и агрегацию. Однако мы ещё не полностью определили наш шахматный набор, и этих инструментов недостаточно для решения всех задач. Мы рассматривали возможность, что игрок может быть человеком или программой с искусственным интеллектом. Нелогично утверждать, что игрок связан с человеком или что реализация искусственного интеллекта является частью объекта игрока. На самом деле нам нужно сказать, что Deep Blue — это игрок или что Гарри Каспаров — это игрок.

Отношение "является" (is a) формируется с помощью наследования. Наследование — это самый известный и, возможно, чрезмерно используемый тип отношения в объектно-ориентированном программировании. Наследование похоже на генеалогическое древо: например, Dusty Phillips — один из авторов этой книги, унаследовал фамилию Phillips от своего отца, который, в свою очередь, унаследовал её от своего отца. В объектно-ориентированном программировании, вместо того чтобы наследовать черты и поведение человека, один класс может наследовать атрибуты и методы от другого класса.

> **Примечание**: В объектно-ориентированном подходе наследование позволяет классу (называемому дочерним или подклассом) перенимать свойства и поведение другого класса (родительского или базового). Это позволяет организовать иерархию классов, уменьшая дублирование кода и обеспечивая гибкость в расширении функциональности.

Например, в нашем шахматном наборе есть 32 фигуры, но только шесть типов фигур (пешки, ладьи, слоны, кони, король и ферзь), каждая из которых ведёт себя по-разному при перемещении. Все эти классы фигур имеют общие свойства, такие как цвет и принадлежность к шахматному набору, но у каждой есть уникальная форма, которая отображается на доске, и разные правила для движения. Посмотрим, как шесть типов фигур могут наследоваться от класса **Piece**:

**Рисунок 1.10: Наследование шахматных фигур от класса Piece**

Пустые стрелки указывают, что отдельные классы фигур наследуются от класса **Piece**. Все дочерние классы автоматически имеют атрибуты **chess_set** и **color**, унаследованные от базового класса. Каждая фигура предоставляет свою форму (для отображения на экране при рендеринге доски) и свой метод **move**, чтобы перемещать фигуру на новую позицию на доске после каждого хода.

Мы знаем, что всем подклассам класса **Piece** нужен метод **move**; в противном случае, когда доска попытается передвинуть фигуру, возникнет ошибка. Возможно, мы захотим создать новую версию шахматной игры, добавив дополнительную фигуру (например, волшебника). Наша текущая модель позволит нам создать эту фигуру, не определив для неё метод **move**. Тогда при попытке доски переместить фигуру возникнет сбой.

> **Примечание**: Чтобы избежать таких ситуаций, мы можем создать "пустой" метод **move** в базовом классе **Piece**, который можно будет переопределить в подклассах. Таким образом, базовая версия метода может выводить сообщение об ошибке, говорящее, что данную фигуру перемещать нельзя.

Переопределение методов в подклассах позволяет создавать мощные объектно-ориентированные системы. Например, если мы хотим реализовать класс **Player** с искусственным интеллектом, мы можем добавить метод **calculate_move**, который принимает объект **Board** и решает, какую фигуру куда переместить. Базовый класс может выбирать случайную фигуру и направление для её перемещения. Затем мы можем переопределить этот метод в подклассе с реализацией Deep Blue. Первый класс подойдёт для игры с новичком, а второй — для вызова гроссмейстеру. Важный момент заключается в том, что другие методы класса, такие как те, которые информируют доску о выбранном ходе, можно не изменять; это поведение может быть разделено между обоими классами.

В случае с шахматными фигурами создание стандартной реализации метода **move** не имеет смысла. Всё, что нам нужно сделать, — это потребовать, чтобы метод **move** был реализован в любом дочернем классе. Это можно сделать, сделав **Piece** абстрактным классом с объявленным абстрактным методом **move**.

> **Примечание**: **Абстрактные методы** — это методы, которые требуют реализации в любых не-абстрактных подклассах, но не содержат реализации в базовом классе. Такой метод как бы говорит: "Мы требуем, чтобы этот метод существовал в любом не-абстрактном подклассе, но мы не определяем его реализацию в этом классе."

На самом деле можно создать абстракцию, которая вообще не реализует ни одного метода. Такой класс лишь указывает, что должен делать класс, но не даёт никаких указаний, как это делать. В некоторых языках такие полностью абстрактные классы называются **интерфейсами**. В Python также можно создать класс, содержащий только абстрактные методы, но это используется довольно редко.

> **Примечание**: Интерфейсы, как правило, описывают поведение, которое должен реализовать класс, но не содержат конкретной реализации. В Python этот функционал достигается с помощью абстрактных классов, которые могут содержать методы-заглушки для будущей реализации.


## Наследование обеспечивает абстракцию

Рассмотрим одно из самых длинных слов в объектно-ориентированном лексиконе: **полиморфизм**. Полиморфизм — это возможность по-разному обрабатывать класс в зависимости от того, какой подкласс реализован. Мы уже видели это на примере системы с шахматными фигурами. Если мы углубим дизайн, то увидим, что объект **Board** может принять ход от игрока и вызвать метод **move** для фигуры. Доске никогда не нужно знать, с каким типом фигуры она имеет дело. Всё, что нужно сделать, — это вызвать метод **move**, и правильный подкласс позаботится о том, чтобы передвинуть фигуру как коня или пешку.

> **Примечание**: **Полиморфизм** позволяет объектам одного класса вести себя по-разному в зависимости от того, к какому подклассу они принадлежат. Это создаёт гибкость при проектировании, так как позволяет использовать единый интерфейс для различных типов объектов.

Полиморфизм — это круто, но слово это редко используется в программировании на Python. Python идет дальше, позволяя обращаться с объектами так, как будто они являются экземплярами родительского класса, даже если это не так. Доска, реализованная на Python, может принять любой объект, имеющий метод **move** — будь то фигура слона, автомобиль или утка. Когда вызывается метод **move**, слон будет перемещаться по диагонали на доске, автомобиль поедет куда-то, а утка поплывет или полетит, в зависимости от её настроения.

Этот вид полиморфизма в Python обычно называется **утиная типизация** (duck typing): "если он ходит как утка и плавает как утка, мы называем его уткой". Нас не волнует, является ли это действительно уткой (является — это основа наследования), важно лишь, чтобы объект умел плавать или ходить. Гуси и лебеди также могут предоставить поведение, похожее на утиное.

> **Примечание**: Утиная типизация позволяет нам работать с объектами на основе их поведения, а не типа. Это открывает возможности для создания новых типов объектов, не используя жёсткую иерархию классов, как в традиционном наследовании.

Этот подход позволяет будущим разработчикам создавать новые типы птиц, не создавая формальную иерархию наследования для всех возможных видов водоплавающих птиц. В примерах с шахматами выше использовалось формальное наследование для покрытия всех возможных фигур в шахматном наборе. Утиная типизация также позволяет программисту расширять дизайн, создавая совершенно другие виды поведения, которые не были предусмотрены изначально. Например, в будущем разработчики могут создать пингвина, который ходит и плавает, совместимого с тем же интерфейсом, не предполагая, что у пингвинов есть общий родительский класс с утками.

## Множественное наследование

Когда мы думаем о наследовании в нашем собственном генеалогическом древе, мы видим, что наследуем черты не только от одного родителя. Когда посторонние говорят гордой матери, что у её сына глаза отца, она обычно отвечает: "Да, но нос у него от меня."

В объектно-ориентированном дизайне также может использоваться **множественное наследование**, которое позволяет подклассу наследовать функциональность сразу от нескольких родительских классов. На практике множественное наследование может быть сложной задачей, и некоторые языки программирования (самый известный из них — Java) строго запрещают его. Однако множественное наследование может быть полезным. Чаще всего оно используется для создания объектов с двумя различными наборами поведения. Например, объект, предназначенный для подключения к сканеру для создания изображения и отправки факса с отсканированным изображением, можно создать с наследованием от двух отдельных классов сканера и факсимильного аппарата.

> **Примечание**: Множественное наследование позволяет классу унаследовать поведение сразу от нескольких классов, что полезно для создания объектов со смешанными функциональностями. Однако это может привести к путанице, если классы имеют пересекающиеся интерфейсы.

Пока у двух классов различный интерфейс, обычно нет ничего вредного в том, чтобы подкласс наследовал оба из них. Однако ситуация становится сложной, если мы наследуем два класса, которые предоставляют пересекающиеся интерфейсы. У сканера и факса нет общих функций, поэтому их можно легко объединить. Противоположный пример — класс **мотоцикл**, у которого есть метод **move**, и класс **лодка**, также содержащий метод **move**.

Если мы хотим объединить их в универсальное амфибийное транспортное средство, как результатирующий класс поймёт, что делать при вызове **move**? На уровне проектирования это необходимо объяснить. (Как моряк, один из авторов, живший на лодке, действительно хочет понять, как это должно работать.)

> **Примечание**: Python имеет определённый порядок разрешения методов (MRO — Method Resolution Order), который помогает понять, какой из альтернативных методов будет использоваться. Хотя правила MRO просты, избежать пересечения интерфейсов ещё проще.

Множественное наследование как техника "миксинов" для объединения различных аспектов может быть полезно. Однако в большинстве случаев объект-композиция может оказаться легче в проектировании.

Наследование — это мощный инструмент для расширения поведения и повторного использования функций. Это одно из самых заметных преимуществ объектно-ориентированного дизайна перед более ранними парадигмами. Поэтому часто это первый инструмент, к которому обращаются программисты, работающие с объектами. Однако важно помнить, что наличие молотка не превращает винты в гвозди. Наследование — идеальное решение для очевидных отношений "является" (is a). В других случаях оно может быть неправильно использовано. Программисты часто используют наследование для совместного использования кода между двумя видами объектов, которые только отдаленно связаны, и между которыми нет отношения "является". Хотя это не обязательно плохой дизайн, это отличный повод задуматься, почему они решили проектировать именно так, и не подошло бы ли лучшее отношение или другой шаблон проектирования.

# Практическое задание

Наше практическое задание будет охватывать многие главы этой книги. Мы будем внимательно изучать одну задачу с разных точек зрения. Очень важно рассмотреть альтернативные дизайны и шаблоны проектирования; мы неоднократно укажем, что не существует единственно правильного ответа — есть несколько хороших решений. Наша цель здесь — предоставить реалистичный пример, который включает в себя реалистичную глубину и сложности, приводящие к трудным компромиссам. Мы стремимся помочь читателю применять концепции объектно-ориентированного программирования и проектирования. Это значит выбирать из технических альтернатив, чтобы создать что-то полезное.

Первая часть задания — обзор проблемы и объяснение, почему мы её решаем. Это предыстория охватит ряд аспектов задачи, которые подготовят нас к проектированию и созданию решений в следующих главах. Часть этого обзора будет включать некоторые диаграммы UML, чтобы отобразить элементы проблемы, которую нужно решить. Эти диаграммы будут развиваться в следующих главах, по мере того как мы будем углубляться в последствия проектных решений и вносить изменения в эти решения.

Как и в случае многих реалистичных задач, авторы вносят свои личные предубеждения и предположения. Чтобы понять последствия этого, можно обратиться к книгам вроде *Technically Wrong*, автором которой является Сара Вахтер-Бётчер.

Наши пользователи хотят автоматизировать задачу, часто называемую **классификацией**. Это основная идея рекомендаций продуктов: если клиент купил продукт X, возможно, ему также будет интересен похожий продукт Y. Мы классифицировали его предпочтения и можем найти другие элементы из этого класса продуктов. Эта задача может включать сложные вопросы организации данных.

Полезно начать с чего-то меньшего и более управляемого. Пользователи хотят в конечном итоге решать задачи, связанные со сложными потребительскими продуктами, но понимают, что решение сложной проблемы — не лучший способ научиться создавать такого рода приложения. Лучше начать с задачи управляемой сложности и постепенно расширять её, пока она не охватит все необходимые функции. Поэтому в этом практическом задании мы будем создавать классификатор для видов ирисов. Это классическая задача, и существует много литературы о подходах к классификации ирисов.

> **Примечание**: Для классификатора требуется **обучающий набор данных**, который используется в качестве примера правильно классифицированных ирисов. Мы обсудим, как выглядит обучающий набор данных, в следующем разделе. Чтобы наглядно отобразить и суммировать программное обеспечение, которое мы будем разрабатывать, мы создадим серию диаграмм с использованием Унифицированного языка моделирования (UML).

Мы рассмотрим задачу, используя метод, называемый **4+1 Виды**. Эти виды включают:
- **Логический вид** данных, их статические атрибуты и взаимосвязи. Это основа объектно-ориентированного проектирования.
- **Процессный вид**, описывающий, как обрабатываются данные. Он может включать модели состояний, диаграммы активности и последовательностей.
- **Вид разработки**, отображающий компоненты кода, которые необходимо создать. Эта диаграмма показывает связи между программными компонентами и то, как определения классов группируются в модули и пакеты.
- **Физический вид** приложения, подлежащего интеграции и развёртыванию. В случаях, когда приложение следует общему шаблону проектирования, сложная диаграмма может быть не нужна. В других случаях диаграмма необходима, чтобы показать, как компоненты интегрируются и развёртываются.
- **Контекстный вид**, который объединяет остальные четыре вида. Контекстный вид часто описывает **акторов** — людей или автоматизированные интерфейсы, которые взаимодействуют с системой. Эти акторы находятся вне системы, и система должна реагировать на эти внешние взаимодействия.

> **Примечание**: Обычно начинать с контекстного вида, чтобы получить общее представление о том, что описывают другие виды. По мере того как мы лучше понимаем пользователей и предметную область, контекст также будет уточняться.

Важно понимать, что все эти 4+1 вида развиваются вместе. Изменения в одном виде, как правило, отражаются на других. Распространённая ошибка — думать, что один из видов является основополагающим, а остальные строятся на его основе, как серия шагов, которые всегда ведут к созданию программного обеспечения.

Начнем с резюме проблемы и некоторого бэкграунда, прежде чем приступать к анализу приложения или проектированию программного обеспечения.

## Введение и обзор задачи

Как мы уже упоминали, начнем с более простой задачи — классификации цветов. Мы собираемся реализовать один из популярных подходов под названием **k-ближайших соседей** (или сокращенно k-NN). Нам потребуется обучающий набор данных, который алгоритм классификации будет использовать в качестве примера правильно классифицированных ирисов. Каждый обучающий образец имеет ряд атрибутов, сведённых к числовым значениям, и окончательную, правильную классификацию (т.е. вид ириса). В этом примере с ирисами каждый образец представляет собой цветок ириса с его атрибутами, такими как форма и размер лепестков, и так далее, которые закодированы в числовой вектор. Этот вектор является обобщённым представлением ириса, к которому добавляется метка с правильным видом ириса.

Имея неизвестный образец (ирис, вид которого мы хотим определить), мы можем измерить расстояние между ним и известными образцами в векторном пространстве. Для некоторой небольшой группы ближайших соседей мы можем провести голосование. Неизвестный образец можно классифицировать в подгруппу, определённую большинством ближайших соседей.

> **Примечание**: k-NN классификация — это метод, который основывается на расчёте расстояний между объектами. Ближайшие соседи, найденные среди обучающего набора данных, "голосуют" за определённый класс для неизвестного объекта, и по их "голосам" определяется итоговая классификация.

Если у нас есть только две размерности (или атрибута), мы можем визуализировать классификацию k-NN следующим образом:

**Рисунок 1.11: k-ближайших соседей**

Наш неизвестный образец — это ромб с меткой "??". Он окружен известными образцами квадратного и круглого видов. Определив трёх ближайших соседей (показаны внутри пунктирного круга), мы можем провести голосование и решить, что неизвестный образец наиболее похож на круглый вид.

Основной концепцией здесь является наличие ощутимых числовых измерений для различных атрибутов. Преобразование слов, адресов и других неупорядоченных данных в упорядоченные числовые значения может быть сложной задачей. Хорошая новость заключается в том, что данные, с которыми мы начнем работать, уже содержат правильно упорядоченные измерения с явными единицами измерения.

> **Примечание**: Важным параметром в k-NN является количество соседей, участвующих в голосовании, — это и есть k-фактор в методе k-ближайших соседей. В нашем концептуальном примере k=3: два из трёх ближайших соседей — круги, а третий — квадрат. Если изменить значение k на 5, это изменит состав группы соседей и может привести к перевесу голосов в пользу квадратов.

Правильность k-параметра проверяется с использованием тестовых данных с известными правильными ответами, чтобы подтвердить, что алгоритм классификации работает достаточно хорошо. На предыдущей диаграмме видно, что ромб был тщательно выбран для того, чтобы быть посередине между двумя кластерами, создавая намеренно сложную задачу классификации.

Популярный набор данных для изучения работы алгоритма — это **данные классификации ирисов**. Дополнительную информацию о нём можно найти [здесь](https://archive.ics.uci.edu/ml/datasets/iris) и на [Kaggle](https://www.kaggle.com/uciml/iris), а также во многих других местах.

> **Примечание**: Более опытные читатели могут заметить некоторые пробелы и возможные противоречия, пока мы движемся по пути объектно-ориентированного анализа и проектирования. Это сделано намеренно. Первоначальный анализ любой значительной проблемы всегда включает обучение и доработку. Этот пример будет развиваться по мере того, как мы будем узнавать больше. Если вы заметили пробел или противоречие, попробуйте создать собственный дизайн и посмотрите, совпадает ли он с выводами, сделанными в следующих главах.

Рассмотрев некоторые аспекты задачи, мы можем создать более конкретный контекст с акторами и сценариями использования, которые описывают, как актор взаимодействует с системой, которую предстоит построить. Начнем с **контекстного вида**.

## Контекстный вид

Контекст нашего приложения, которое классифицирует виды ирисов, включает две категории акторов:

- **"Ботаник"**, который предоставляет правильно классифицированные обучающие данные и набор тестовых данных. Ботаник также запускает тесты для установления оптимальных параметров классификации. В простом случае с k-NN они могут определить, какое значение k следует использовать.

- **"Пользователь"**, которому нужно классифицировать неизвестные данные. Пользователь проводит точные измерения и делает запрос с измеренными данными для получения классификации от этой системы классификации. Название "Пользователь" кажется неопределённым, но пока мы оставим его и отложим переименование до тех пор, пока не возникнет необходимость.

> **Примечание**: Эти акторы отражают разные типы взаимодействий с системой. Ботаник занимается подготовкой данных и настройкой алгоритма, а Пользователь — непосредственным использованием классификатора для решения прикладных задач.

На следующей диаграмме UML показаны два актора и три сценария, которые мы будем рассматривать:

**Рисунок 1.12: Контекстная диаграмма UML**

Система в целом изображена в виде прямоугольника. Внутри него расположены овалы, представляющие пользовательские истории (user stories). В UML формы имеют свои значения: прямоугольники зарезервированы для объектов, а овалы и круги — для пользовательских историй, которые являются интерфейсами системы.

Для выполнения полезной обработки данных нам нужны правильно классифицированные обучающие данные. Каждая группа данных состоит из двух частей: набора для обучения и набора для тестирования. Мы будем называть этот общий набор "обучающими данными" вместо более длинного (но точного) "обучающие и тестовые данные".

Параметры настройки задаёт ботаник, который должен проверить результаты тестов, чтобы убедиться в корректной работе классификатора. Эти параметры включают:
- Расчёт расстояния, который будет использоваться.
- Количество соседей, которые будут учтены для голосования.

> **Примечание**: Эти параметры являются ключевыми элементами настройки k-NN классификации. Различные способы вычисления расстояния и значения k могут значительно повлиять на точность классификатора.

Мы подробнее рассмотрим эти параметры в разделе **Процессный вид** позже в этой главе. Мы также вернёмся к этим идеям в следующих главах с практическими заданиями. Расчёт расстояний — интересная проблема.

Можно определить набор экспериментов в виде сетки с вариантами и методично заполнять её результатами тестирования. Комбинация, которая покажет наилучший результат, будет рекомендованным набором параметров от ботаника. В нашем случае имеется два параметра, и сетка представляет собой двумерную таблицу, как показано ниже. Для более сложных алгоритмов "сетка" может быть многомерным пространством:

| k-факторы         | k=3           | k=5           | k=7           | … |
|-------------------|---------------|---------------|---------------|---|
| Евклидова метрика | Результат теста | Результат теста | Результат теста | … |
| Манхэттенская метрика | Результат теста | Результат теста | Результат теста | … |
| Чебышевская метрика | Результат теста | Результат теста | Результат теста | … |
| Соренсена          | Результат теста | Результат теста | Результат теста | … |
| Другие?           | Результат теста | Результат теста | Результат теста | … |

После тестирования **Пользователь** может делать запросы, предоставляя неизвестные данные для получения результатов классификации от обученной классификационной системы. В долгосрочной перспективе этот "Пользователь" может быть не человеком, а подключением от какого-либо сайта, например, от системы рекомендаций интернет-магазина.

Мы можем обобщить каждый из этих сценариев в виде пользовательской истории:

- **Как Ботаник, я хочу предоставить системе правильно классифицированные обучающие и тестовые данные, чтобы пользователи могли точно идентифицировать растения.**
- **Как Ботаник, я хочу изучить результаты тестов классификатора, чтобы быть уверенным, что новые образцы будут классифицированы корректно.**
- **Как Пользователь, я хочу иметь возможность предоставить несколько ключевых измерений классификатору и получить корректную классификацию вида ириса.**

> **Примечание**: Эти истории помогают нам определить основные требования к системе, а также понять роли и действия акторов в ней.

Используя существительные и глаголы из пользовательских историй, мы можем создать логический вид данных, которые будет обрабатывать наше приложение.

## Логический вид

Рассматривая контекстную диаграмму, можно заметить, что обработка начинается с обучающих и тестовых данных. Это правильно классифицированные образцы данных, которые используются для проверки нашего алгоритма классификации. На следующей диаграмме показан один из способов представления класса, который содержит различные наборы обучающих и тестовых данных:

**Рисунок 1.13: Диаграмма классов для обучения и тестирования**

На диаграмме изображён класс **TrainingData** с атрибутами, которые присутствуют у каждого экземпляра этого класса. Объект **TrainingData** даёт нашей коллекции образцов имя и хранит даты, когда были завершены загрузка и тестирование. На данный момент, кажется, что каждому объекту **TrainingData** должен соответствовать единственный параметр настройки, **k**, используемый в алгоритме k-NN. Экземпляр также включает два списка индивидуальных образцов: **training_list** и **testing_list**.

> **Примечание**: На UML-диаграммах классов каждый класс изображается в виде прямоугольника, который обычно состоит из трёх разделов: имя класса, атрибуты и методы.

Каждый объект класса **Sample** имеет несколько атрибутов: четыре числовых значения с плавающей точкой и строковое значение, представляющее классификацию, присвоенную образцу ботаником. В этом случае мы используем название атрибута **class** для обозначения вида, так как это соответствует исходным данным.

> **Примечание**: Стрелки на UML-диаграмме показывают два типа отношений, обозначенных заполненными или пустыми ромбами. Заполненный ромб показывает композицию (объект **TrainingData** состоит из двух коллекций). Пустой ромб показывает агрегацию (список **List[Sample]** содержит объекты **Sample**).

Чтобы напомнить, что мы уже узнали:

- **Композиция** — это связь существования: объект **TrainingData** не может существовать без двух объектов **List[Sample]**. Соответственно, **List[Sample]** не используется в нашем приложении, если не является частью **TrainingData**.
- **Агрегация**, с другой стороны, — это связь, при которой элементы могут существовать независимо друг от друга. В этой диаграмме несколько объектов **Sample** могут быть частью **List[Sample]** или существовать отдельно от списка.

> **Примечание**: Мы показываем **List[Sample]** как отдельный класс объектов. Это обобщённый класс **List** Python, уточнённый с указанием, что список будет содержать только объекты **Sample**. В более упрощённой диаграмме этот уровень детализации можно избежать, чтобы не усложнять анализ данных.

В упрощенной диаграмме можно свести отношения к более сжатой форме, чтобы сосредоточиться на аналитической работе:

**Рисунок 1.14: Упрощённая диаграмма классов**

Эта слегка сокращённая форма помогает при аналитической работе, когда внутренние структуры данных не так важны. Однако при проектировании системы такие детали становятся важными, так как необходима конкретная информация о классах Python.

> **Примечание**: Имея начальный эскиз, мы сравним этот логический вид с каждым из трёх сценариев, описанных в контекстной диаграмме на рисунке 1.12 в предыдущем разделе. Мы хотим убедиться, что все данные и процессы в пользовательских историях могут быть распределены как обязанности среди классов, атрибутов и методов на диаграмме.

Проверяя пользовательские истории, мы обнаруживаем две проблемы:
- Непонятно, как тестирование и настройка параметров вписываются в эту диаграмму. Мы знаем, что требуется **k**-фактор, но отсутствуют результаты тестов, чтобы показать альтернативные значения **k** и последствия их выбора.
- Запрос пользователя не отображён, так же как и ответ на запрос. Ни один класс не отвечает за эти элементы.

Первый пункт указывает на необходимость ещё раз пересмотреть пользовательские истории и попытаться создать более точное логическое представление. Второй пункт касается границ задачи. Несмотря на отсутствие деталей веб-запросов и ответов, важно сначала описать основную предметную область — классификацию и алгоритм k-NN. Веб-сервисы для обработки запросов пользователей представляют собой одну из возможных технологий, и мы можем отложить их на начальном этапе проектирования.

Теперь мы сосредоточимся на обработке данных. Мы следуем порядку, который кажется эффективным для создания описания приложения. Данные должны быть описаны в первую очередь; это наиболее устойчивая часть, которая остаётся неизменной на протяжении всех этапов уточнения обработки. Обработка данных может изменяться в зависимости от контекста, пользовательского опыта и предпочтений.

## Процессный вид

У нас есть три отдельные пользовательские истории. Это не обязательно заставляет нас создавать три процессные диаграммы. Для сложной обработки может быть больше процессных диаграмм, чем пользовательских историй. В некоторых случаях пользовательская история может быть настолько простой, что не требует тщательно продуманной диаграммы.

Для нашего приложения, похоже, имеются по крайней мере три интересных процесса:
- Загрузка начального набора **Samples**, составляющего данные для **TrainingData**.
- Запуск тестирования классификатора с заданным значением **k**.
- Выполнение запроса на классификацию с новым объектом **Sample**.

Мы набросаем диаграммы активности для этих случаев использования. **Диаграмма активности** суммирует несколько изменений состояний. Обработка начинается с начального узла и продолжается, пока не будет достигнут конечный узел. В транзакционных приложениях, таких как веб-сервисы, обычно опускается показ общего движка веб-сервера. Это избавляет нас от описания стандартных функций HTTP, таких как заголовки, куки и вопросы безопасности. Вместо этого мы сосредотачиваемся на уникальной обработке, выполняемой для создания ответа на каждый тип запроса.

> **Примечание**: Действия на диаграммах активности отображаются в виде прямоугольников с закруглёнными углами. Если конкретные классы объектов или компоненты программного обеспечения имеют отношение к процессу, они могут быть связаны с соответствующими действиями.

Что более важно, так это убедиться, что логический вид обновляется по мере появления идей во время работы над процессным видом. Сложно полностью завершить один из этих видов в изоляции. Важнее вносить поэтапные изменения в каждый из видов по мере появления новых идей решения. В некоторых случаях может потребоваться дополнительный ввод данных от пользователя, что также приведет к развитию этих видов.

Мы можем набросать диаграмму, чтобы показать, как система реагирует, когда ботаник предоставляет начальные данные. Вот первый пример:

**Рисунок 1.15: Диаграмма активности**

Коллекция значений **KnownSample** будет разделена на два подмножества: обучающее и тестовое. В нашем описании задачи или пользовательских историях нет правила для такого разделения; этот пробел показывает, что в исходной пользовательской истории не хватает деталей. Когда в пользовательских историях отсутствуют детали, логический вид также может быть неполным. Пока что мы можем предположить, что большая часть данных — скажем, 75% — будет использована для обучения, а оставшиеся 25% — для тестирования.

> **Примечание**: Часто полезно создавать аналогичные диаграммы для каждой из пользовательских историй. Также важно, чтобы все действия имели соответствующие классы для реализации шагов и отображения изменений состояния, вызванных каждым шагом.

Мы включили глагол **Partition** (разделить) в этой диаграмме. Это предполагает, что потребуется метод для реализации этого действия. Это может привести к пересмотру модели классов, чтобы убедиться, что обработка может быть реализована.

Теперь мы перейдем к рассмотрению некоторых компонентов, которые нужно будет создать. Поскольку это предварительный анализ, наши идеи будут развиваться по мере выполнения более детального проектирования и начала создания определений классов.

## Вид разработки

Часто возникает тонкий баланс между конечным развертыванием и компонентами, которые нужно разработать. В редких случаях ограничений по развертыванию практически нет, и разработчик может свободно проектировать компоненты. Тогда физический вид разрабатывается на основе требований к компонентам. В более распространенных случаях имеется конкретная целевая архитектура, которую нужно использовать, и элементы физического вида фиксированы.

Существует несколько способов развернуть этот классификатор как часть более крупного приложения. Мы можем создать настольное приложение, мобильное приложение или веб-сайт. Из-за повсеместного распространения интернета одним из распространенных подходов является создание веб-сайта с возможностью подключения к нему с настольных компьютеров и мобильных устройств.

> **Примечание**: Архитектура веб-сервиса позволяет отправлять запросы на сервер, а ответы могут быть представлены в виде HTML-страниц для браузера или JSON-документов, которые могут отображаться в мобильном приложении.

Некоторые запросы будут содержать целые новые наборы обучающих данных, а другие запросы будут предназначены для классификации неизвестных образцов. Ниже мы рассмотрим архитектуру более подробно в разделе о физическом виде. Мы можем использовать фреймворк Flask для создания веб-сервиса. Дополнительную информацию о Flask можно найти в книгах *Mastering Flask Web Development* или *Learning Flask Framework*.

Следующая диаграмма показывает некоторые из компонентов, которые потребуется создать для приложения на основе Flask:

**Рисунок 1.16: Компоненты, которые нужно разработать**

На этой диаграмме изображен Python-пакет **Classifier**, который содержит несколько модулей. Три основных модуля включают:

- **Data Model**: (Поскольку мы все еще на стадии анализа, это имя пока не соответствует Python-стилю; мы изменим его позже на этапе реализации.) Часто полезно разделить классы, определяющие предметную область, на модули. Это позволяет тестировать их изолированно от любого приложения, которое использует эти классы. Мы сосредоточимся на этой части, так как она является фундаментальной.
  
- **View Functions**: (Также это название на стадии анализа, не соответствует Python-стилю). Этот модуль будет создавать экземпляр класса Flask — нашего приложения. Он определит функции, которые обрабатывают запросы, создавая ответы, которые могут быть отображены мобильным приложением или браузером. Эти функции раскрывают функциональные возможности модели и не затрагивают ту же глубину и сложность, что и сама модель; мы не будем подробно рассматривать этот компонент в рамках практического задания.
  
- **Tests**: Этот модуль будет содержать модульные тесты для модели и функций представления. Тесты являются важной частью для обеспечения работоспособности программного обеспечения, и они будут рассмотрены в главе 13 — *Тестирование объектно-ориентированных программ*.

> **Примечание**: На диаграмме включены стрелки зависимости, обозначенные пунктирными линиями. Их можно аннотировать с использованием пометки "imports", чтобы помочь прояснить, как связаны различные пакеты и модули в Python.

По мере того, как мы будем продвигаться по проектированию в следующих главах, мы будем дополнять этот начальный вид. После того как мы обдумали, что нужно построить, мы можем перейти к рассмотрению того, как это будет развернуто, создав физический вид приложения. Как упомянуто выше, разработка и развертывание часто выполняются параллельно, так как два вида часто разрабатываются вместе.

## Физический вид

Физический вид показывает, как программное обеспечение будет установлено на физическое оборудование. Для веб-сервисов часто используется концепция **непрерывной интеграции и непрерывного развертывания (CI/CD)**. Это означает, что изменение программного обеспечения тестируется как отдельная единица, интегрируется с существующими приложениями, тестируется в составе интегрированной системы, а затем развертывается для пользователей.

Хотя обычно предполагается развертывание в виде веб-сайта, его также можно развернуть как консольное приложение, которое может выполняться на локальном компьютере или в облаке. Также возможен вариант создания веб-приложения вокруг основного классификатора. Следующая диаграмма показывает структуру веб-сервера:

**Рисунок 1.17: Диаграмма сервера приложения**

На этой диаграмме клиентские и серверные узлы представлены в виде трёхмерных «коробок» с установленными на них «компонентами». Мы выделили три компонента:

- **Клиент** с приложением **client app**. Это приложение подключается к веб-сервису классификатора и отправляет RESTful запросы. Это может быть веб-сайт, написанный на JavaScript, или мобильное приложение, написанное на Kotlin или Swift. Все эти фронтенды используют общую защищенную HTTPS связь с нашим веб-сервером. Эта защищенная связь требует настройки сертификатов и пары ключей шифрования.

- **Веб-сервер GUnicorn**. Этот сервер обрабатывает множество деталей запросов к веб-сервису, включая важный протокол HTTPS. Подробнее можно узнать на сайте [GUnicorn](https://docs.gunicorn.org/en/stable/index.html).

- **Наше приложение Classifier**. На этой диаграмме упрощены все внутренние сложности, и весь пакет **Classifier** представлен как небольшой компонент в более крупной архитектуре веб-сервиса. Это можно реализовать с использованием фреймворка Flask.

> **Примечание**: Из этих компонентов приложение **client app** не входит в объем работ, необходимых для разработки классификатора. Мы включили его для иллюстрации контекста, но на самом деле не будем его разрабатывать.

Мы использовали пунктирную стрелку зависимости, чтобы показать, что приложение **Classifier** является зависимостью для веб-сервера. **GUnicorn** импортирует наш объект веб-сервера и использует его для ответа на запросы.

Теперь, когда у нас есть общее представление о приложении, мы можем подумать о написании кода. В процессе разработки полезно поддерживать диаграммы в актуальном состоянии. Иногда они служат удобной картой в «лесу» кода.


## Заключение

В этом практическом задании выделяются несколько ключевых концепций:

1. **Программные приложения могут быть довольно сложными.** Существует пять видов, которые помогают отразить пользователей, данные, обработку, компоненты для разработки и целевую физическую реализацию.

2. **Ошибки неизбежны.** В этом обзоре есть некоторые пробелы. Важно двигаться вперед с частичными решениями. Одним из преимуществ Python является возможность быстрого построения программного обеспечения, что позволяет нам не вкладываться глубоко в неудачные идеи. Мы можем (и должны) быстро удалять и заменять код.

3. **Будьте открыты для расширений.** После реализации мы увидим, что настройка параметра k — утомительное занятие. Следующим важным шагом будет автоматизация настройки с использованием алгоритма подбора параметров (grid search). Часто полезно отложить эти задачи и сначала сделать что-то рабочее, а затем расширить это, добавив полезные функции.

4. **Старайтесь четко распределить ответственность между классами.** Это было частично успешно, однако некоторые обязанности остаются расплывчатыми или совсем не определены. Мы вернемся к этому, когда углубимся в детали реализации.

В следующих главах мы более глубоко рассмотрим эти темы. Поскольку наша цель — представить реалистичный рабочий процесс, потребуется переделка некоторых частей. Некоторые проектные решения могут быть пересмотрены, поскольку читатель познакомится с новыми методами объектно-ориентированного программирования на Python. Кроме того, некоторые части решения будут развиваться по мере улучшения понимания проектных решений и самой задачи. Переделка, основанная на полученных уроках, является частью гибкого подхода к разработке.

# Основные моменты

В этой главе были рассмотрены следующие ключевые моменты:
- **Анализ требований** к задаче в контексте объектно-ориентированного подхода.
- Как рисовать **диаграммы UML** для визуального представления работы системы.
- Обсуждение объектно-ориентированных систем с использованием правильной терминологии.
- Понимание различий между классом, объектом, атрибутом и поведением.
- Некоторые техники объектно-ориентированного проектирования используются чаще других, и в нашем примере мы сосредоточились на:
  - **Инкапсуляции** функций в классы.
  - **Наследовании** для расширения класса новыми функциями.
  - **Композиции** для построения класса из компонентных объектов.

# Практические задания

Эта книга носит практический характер. Мы не предлагаем вам искусственные задачи для объектно-ориентированного анализа и проектирования, а хотим дать идеи, которые вы сможете применить в своих проектах. Если у вас уже есть опыт объектно-ориентированного программирования, это задание не потребует много усилий. Однако оно может быть полезным для тех, кто давно работает с Python, но никогда не углублялся в ООП.

1. **Проанализируйте недавний проект.** Определите наиболее важный объект в дизайне и подумайте, какие атрибуты у него могут быть (цвет, вес, размер, стоимость и т.д.).

2. **Подумайте о типах атрибутов.** Были ли они примитивами или классами? Некоторые атрибуты могли быть поведениями, замаскированными под данные.

3. **Проанализируйте будущий проект.** Определите требования и взаимодействующие объекты. Нарисуйте диаграмму классов с уровнями абстракции и найдите места для использования наследования или композиции.

4. **Найдите учебные материалы по UML.** Найдите подходящие для себя ресурсы и попробуйте нарисовать несколько диаграмм классов или последовательностей для объектов, которые вы ранее определили.

# Резюме

В этой главе мы провели краткий обзор терминологии объектно-ориентированного программирования с акцентом на проектирование. Мы разделили объекты на классы, описали их атрибуты и поведение через интерфейс класса. Абстракция, инкапсуляция и скрытие информации оказались связанными концепциями. Существуют различные типы отношений между объектами, включая ассоциацию, композицию и наследование. Синтаксис UML может быть полезным как для удовольствия, так и для эффективного общения.

В следующей главе мы рассмотрим, как реализовать классы и методы в Python.




