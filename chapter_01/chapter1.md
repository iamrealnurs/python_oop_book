# 1. Проектирование на основе объектов

> **Примечание**: Слово "дизайн" в русском и английском языках может иметь разные значения. В русском языке оно чаще всего воспринимается как оформление внешнего вида, тогда как в английском, особенно в контексте программирования, оно может также означать "проектирование."

В разработке программного обеспечения проектирование часто рассматривается как шаг, предшествующий программированию. Однако это не совсем верно; на практике анализ, программирование и проектирование пересекаются, комбинируются и переплетаются. В этой книге мы будем затрагивать одновременно вопросы проектирования и программирования, не пытаясь разделять их на отдельные категории. Одним из преимуществ языка Python является возможность ясно выразить проектирование.

В этой главе мы поговорим о том, как можно пройти путь от хорошей идеи к написанию программы. Мы создадим некоторые артефакты проектирования — такие как диаграммы, — которые помогут нам прояснить наши мысли до начала написания кода. 

> **Примечание**: Термин "артефакты" в данном контексте обозначает результаты проектировочной работы, такие как диаграммы и документы. Это специальные материалы, которые помогают в разработке, не путать с привычным значением слова "артефакт."

Мы рассмотрим следующие темы:
- Что означает объектно-ориентированность
- Разница между объектно-ориентированным проектированием и объектно-ориентированным программированием
- Основные принципы объектно-ориентированного проектирования
- Основы унифицированного языка моделирования (UML) и когда его использование не является излишним

Мы также введем практический пример проектирования для этой книги, используя модель архитектурного представления "4+1".

> **Примечание**: "Практический пример" (case study) — это метод представления проектирования или разработки, основанный на использовании реального или условного примера задачи.

В этом разделе мы затронем следующие вопросы:
- Обзор классической задачи машинного обучения — известной проблемы классификации Ирисов

> **Примечание**: "Классификатор" (classifier) в данном случае обозначает алгоритм машинного обучения, способный относить объекты к определенным классам или категориям. В данной задаче "классификатор" используется для определения типа ириса на основе его характеристик.

- Общий контекст обработки для этого классификатора
- Набросок двух представлений иерархии классов, которые, по-видимому, будут адекватны для решения задачи

> **Примечание**: "Иерархия классов" (class hierarchy) представляет собой структуру, описывающую, как классы связаны между собой. Это помогает организовать классы в системе, особенно в объектно-ориентированном проектировании.

Таким образом, эта глава даст базовое представление о переходе от идеи к проектированию программы, используя язык Python и базовые принципы объектно-ориентированного подхода.

# Введение в объектно-ориентированный подход

Все знают, что такое объект: это материальная вещь, которую можно ощутить, потрогать и использовать. Первые объекты, с которыми мы взаимодействуем, как правило, — это игрушки младенцев. Деревянные кубики, пластиковые фигуры и крупные детали головоломок являются первыми знакомыми объектами. Младенцы быстро понимают, что разные объекты выполняют разные действия: колокольчики звенят, кнопки нажимаются, рычаги тянутся.

Определение объекта в разработке программного обеспечения не сильно отличается. Программные объекты не являются материальными предметами, которые можно взять в руки или почувствовать, но они представляют собой модели чего-то, что может выполнять определённые действия и на что можно воздействовать. Формально объект — это совокупность данных и связанных с ними действий.

Когда мы говорим об объекте, что означает объектно-ориентированный подход? Согласно словарю, "ориентированный" означает "направленный на". Объектно-ориентированное программирование (англ. Object-Oriented Programming, OOP) означает написание кода, направленного на моделирование объектов. Это один из многих методов описания действий сложных систем. Он подразумевает описание взаимодействующих объектов через их данные и поведение.

Если вы знакомы с популярными концепциями, то, вероятно, встречали такие термины, как объектно-ориентированный анализ (англ. Object-Oriented Analysis, OOA), объектно-ориентированное проектирование (англ. Object-Oriented Design, OOD), объектно-ориентированный анализ и проектирование (англ. Object-Oriented Analysis and Design, OOAD) и объектно-ориентированное программирование (OOP). Все они связаны с общей объектно-ориентированной концепцией.

На самом деле, анализ, проектирование и программирование — это все этапы разработки программного обеспечения. Определение их как "объектно-ориентированных" указывает на конкретный подход к разработке.

**Объектно-ориентированный анализ (OOA)** — это процесс анализа задачи, системы или задачи, которую кто-то хочет превратить в работающую программу, с целью выявления объектов и взаимодействий между ними. Этап анализа посвящён определению того, что необходимо сделать.

Результатом этапа анализа является описание системы, часто в форме требований. Если бы мы завершили этап анализа за один шаг, то превратили бы задачу, такую как *«Как ботаник, я нуждаюсь в сайте, который поможет пользователям классифицировать растения для их правильного определения»*, в набор необходимых функций. Примером могут быть следующие требования, описывающие действия, которые должен выполнить посетитель сайта. Каждый элемент является действием, связанным с объектом; действия выделены курсивом, а объекты — жирным шрифтом:

- *Просмотр* **Предыдущих загрузок**
- *Загрузка* **новых известных примеров**
- *Тестирование* на **качество**
- *Просмотр* **товаров**
- *Просмотр* **рекомендаций**

> **Примечание**: На самом деле, термин "анализ" здесь может быть немного вводящим в заблуждение. Младенец, о котором мы говорили ранее, не анализирует кубики и детали головоломки. Скорее, он исследует свою среду, манипулирует формами и пробует, подходят ли они друг к другу. Возможно, более подходящим термином здесь было бы "объектно-ориентированное исследование". В разработке программного обеспечения начальные этапы анализа включают интервьюирование клиентов, изучение их процессов и устранение ненужных вариантов.

**Объектно-ориентированное проектирование (OOD)** — это процесс преобразования таких требований в спецификацию реализации. Проектировщик должен дать названия объектам, определить их поведение и формально указать, какие объекты могут запускать определенные действия на других объектах. Этап проектирования направлен на то, чтобы превратить *что нужно сделать* в *как это должно быть сделано*.

Результатом этапа проектирования является спецификация реализации. Если бы мы завершили этап проектирования за один шаг, то превратили бы требования, определённые в ходе объектно-ориентированного анализа, в набор классов и интерфейсов, которые могли бы быть реализованы (в идеале) в любом объектно-ориентированном языке программирования.

**Объектно-ориентированное программирование (OOP)** — это процесс преобразования проекта в работающую программу, которая выполняет то, что изначально запросил заказчик.

Конечно, в идеальном мире мы могли бы следовать этим этапам один за другим, в идеальном порядке, как советуют классические учебники. Однако в реальности всё гораздо сложнее. Каким бы тщательным ни был процесс разделения этих этапов, всегда остаются моменты, которые нуждаются в дополнительном анализе на этапе проектирования, а при программировании обнаруживаются особенности, требующие уточнений в проекте.

Большинство методов разработки программного обеспечения XXI века признаёт, что этот каскадный (или "водопадный") процесс не всегда работает. Более эффективной оказывается итеративная модель разработки. В итеративной разработке небольшая часть задачи моделируется, проектируется и программируется, после чего продукт пересматривается и расширяется для улучшения каждой функции и добавления новых в серии коротких циклов разработки.

Остальная часть этой книги посвящена объектно-ориентированному программированию, но в этой главе мы рассмотрим основные принципы объектно-ориентированного подхода в контексте проектирования. Это позволит нам понять концепции без необходимости отвлекаться на синтаксис языка или сообщения об ошибках Python.

# Объекты и классы

Объект — это совокупность данных с связанным с ними поведением. Как мы можем отличить одни типы объектов от других? Например, яблоки и апельсины — это оба объекта, но, как говорится, "их нельзя сравнивать". В программировании компьютеров яблоки и апельсины редко моделируются, но представим, что мы создаём приложение для инвентаризации на фруктовой ферме. В рамках этого примера мы предположим, что яблоки хранятся в бочках, а апельсины — в корзинах.

На данный момент наша предметная область включает четыре типа объектов: яблоки, апельсины, корзины и бочки. В объектно-ориентированном моделировании термин, используемый для обозначения типа объекта, — это "класс". Таким образом, с технической точки зрения у нас теперь есть четыре класса объектов.

Важно понимать разницу между объектом и классом. Классы описывают связанные объекты. Они подобны чертежам для создания объекта. Перед вами может находиться три апельсина. Каждый апельсин — это отдельный объект, но у всех трёх есть атрибуты и поведение, связанные с одним классом: общим классом апельсинов.

> **Примечание**: В объектно-ориентированном проектировании часто используется Унифицированный язык моделирования (англ. Unified Modeling Language, UML). UML помогает визуально представлять отношения между классами, используя диаграммы классов. Эти диаграммы позволяют программистам легко и наглядно передавать информацию о структуре проекта.

Связь между четырьмя классами объектов в нашей системе инвентаризации можно описать с помощью диаграммы классов на языке UML (UML — это английская аббревиатура от Unified Modeling Language, поскольку трёхбуквенные аббревиатуры никогда не выходят из моды). Вот наша первая диаграмма классов:

**Рисунок 1.1: Диаграмма классов**

Эта диаграмма показывает, что экземпляры класса **Orange** (обычно называемые "апельсины") как-то связаны с **Basket**, а экземпляры класса **Apple** ("яблоки") связаны с **Barrel**. Связь (association) — это самый простой способ, которым экземпляры двух классов могут быть связаны.

Синтаксис диаграмм UML в целом довольно очевиден; вам не нужно изучать учебник, чтобы (в основном) понять, что происходит, глядя на такую диаграмму. UML также довольно легко рисовать, и он интуитивно понятен. Ведь многие, описывая классы и их связи, естественно рисуют прямоугольники с линиями между ними. Наличие стандарта, основанного на таких интуитивных диаграммах, упрощает общение между программистами, проектировщиками, менеджерами и членами команды.

Обратите внимание, что диаграмма UML обычно изображает определения классов, но мы описываем атрибуты объектов. Диаграмма показывает класс **Apple** и класс **Barrel**, указывая, что конкретное яблоко находится в определенной бочке. Хотя UML можно использовать для отображения отдельных объектов, это редко бывает необходимо. Изображение классов даёт достаточно информации об объектах, являющихся экземплярами каждого класса.

Некоторые программисты относятся к UML скептически, считая его пустой тратой времени. Указывая на итеративную разработку, они утверждают, что формальные спецификации, оформленные в виде сложных диаграмм UML, станут устаревшими ещё до их реализации, а поддержка этих формальных диаграмм будет лишь напрасной тратой времени и никому не принесет пользы.

Тем не менее, любая команда, состоящая более чем из одного человека, рано или поздно должна будет обсудить детали создаваемых компонентов. UML крайне полезен для обеспечения быстрого, лёгкого и последовательного общения. Даже те организации, которые пренебрегают формальными диаграммами классов, часто используют неформальную версию UML на совещаниях по проектированию или в командных обсуждениях.

Более того, самый важный человек, с которым вам придётся общаться, — это вы сами в будущем. Мы все думаем, что сможем вспомнить принятые решения по проектированию, но всегда бывают моменты "Зачем я это сделал?" в будущем. Если мы сохраним черновые схемы, сделанные в начале проектирования, они в конечном итоге станут полезной справкой.

Эта глава, однако, не предназначена как учебник по UML. Таких учебников много в интернете, а также существует множество книг на эту тему. UML охватывает не только диаграммы классов и объектов; у него также есть синтаксис для случаев использования, развертывания, изменений состояния и активностей. Мы рассмотрим некоторые общие элементы синтаксиса диаграмм классов в рамках обсуждения объектно-ориентированного проектирования. Вы сможете освоить структуру на примерах и неосознанно начнёте использовать синтаксис, вдохновлённый UML, в своих командных или личных заметках по проектированию.

Наша начальная диаграмма, хотя и корректна, не напоминает нам, что яблоки хранятся в бочках и сколько бочек может вместить одно яблоко. Она просто показывает, что яблоки как-то связаны с бочками. Ассоциация между классами часто очевидна и не нуждается в дополнительном пояснении, но у нас есть возможность добавлять дополнительные уточнения по мере необходимости.

> **Примечание**: Одним из преимуществ UML является то, что большинство элементов в нем являются опциональными. Мы указываем в диаграмме только ту информацию, которая имеет смысл в текущей ситуации. На быстрой сессии на доске можно просто начертить линии между прямоугольниками. В формальном документе можно пойти в детали.

В случае с яблоками и бочками можно предположить, что связь означает, что в одну бочку можно положить несколько яблок. Однако, чтобы не возникло путаницы с тем, что "одно яблоко портит одну бочку", мы можем улучшить диаграмму, как показано здесь:

**Рисунок 1.2: Диаграмма классов с дополнительными деталями**

Эта диаграмма показывает, что апельсины хранятся в корзинах, и добавлена стрелка, указывающая, что помещается куда. Она также указывает количество объектов, которые могут быть задействованы в связи с обеих сторон ассоциации. Одна **Basket** может содержать много (обозначено символом *) объектов **Orange**. Любой объект **Orange** может находиться ровно в одной **Basket**. Это количество называется **мощностью (multiplicity)** объекта. Этот термин также можно встретить под названием **кардинальность (cardinality)**. Можно представить себе кардинальность как определённое число или диапазон, тогда как мощность понимается как обобщенное "больше чем один экземпляр".

> **Примечание**: Иногда бывает трудно вспомнить, какое число мощности должно находиться на каком конце линии связи. Мощность, ближайшая к классу, указывает количество объектов этого класса, которые могут быть связаны с любым одним объектом на другом конце связи. Для ассоциации "яблоки в бочках", читая слева направо, многие экземпляры класса **Apple** (то есть много объектов **Apple**) могут находиться в одной бочке. Читая справа налево, ровно одна **Barrel** может быть связана с любым одним **Apple**.

Мы рассмотрели основы классов и то, как они задают отношения между объектами. Теперь нам нужно обсудить атрибуты, которые определяют состояние объекта, и поведение объекта, которое может включать изменение состояния или взаимодействие с другими объектами.


# Определение атрибутов и поведения

Теперь у нас есть представление об основных терминах объектно-ориентированного подхода. Объекты — это экземпляры классов, которые могут быть связаны друг с другом. Экземпляр класса — это конкретный объект с собственным набором данных и поведения; например, определённый апельсин на столе перед нами является экземпляром общего класса апельсинов.

> **Примечание**: Термин "экземпляр" в данном контексте обозначает отдельный объект, созданный на основе класса. Каждый экземпляр уникален, но обладает общими характеристиками с другими экземплярами того же класса.

У апельсина есть состояние, например, он может быть спелым или зелёным; мы задаём состояние объекта с помощью значений конкретных **атрибутов**.

> **Примечание**: Атрибуты объекта — это свойства, которые определяют его состояние. Они представляют собой данные, хранящиеся внутри объекта, и описывают его характеристики, такие как цвет, размер или степень зрелости в случае с апельсином.

Кроме того, у апельсина есть поведение. Сами по себе апельсины обычно пассивны. Изменения состояния накладываются на них извне. Давайте более подробно рассмотрим значения этих двух понятий — состояние и поведение.

> **Примечание**: В объектно-ориентированном программировании **поведение** объекта относится к действиям, которые он может выполнять, или к действиям, которые могут быть выполнены с ним.


## Данные описывают состояние объекта

Начнём с данных. Данные представляют собой отдельные характеристики конкретного объекта; его текущее состояние. Класс может определять конкретные наборы характеристик, которые являются частью всех объектов, входящих в этот класс. Любой конкретный объект может иметь разные значения данных для данных характеристик. Например, три апельсина на нашем столе (если мы ещё не съели ни одного) могут иметь разный вес. У класса апельсинов может быть атрибут **вес**, чтобы представлять этот параметр. Все экземпляры класса апельсинов имеют атрибут веса, но у каждого апельсина это значение может быть разным. Однако атрибуты не обязаны быть уникальными; два апельсина могут иметь одинаковый вес.

> **Примечание**: Термин "атрибуты" часто также называют "членами" или "свойствами". Некоторые авторы предполагают, что эти термины имеют разные значения, например, что атрибуты можно изменять, в то время как свойства могут быть только для чтения. В языке Python свойство можно определить как доступное только для чтения, но его значение всё равно будет основываться на атрибутах, которые, в конечном счёте, можно изменить, что делает концепцию "только для чтения" практически неактуальной. В этой книге мы будем использовать термины "атрибут" и "свойство" взаимозаменяемо. Кроме того, как мы обсудим в Главе 5, "Когда использовать объектно-ориентированное программирование", ключевое слово `property` имеет особое значение в Python для определённого типа атрибута.

В Python атрибут можно также называть **переменной экземпляра**. Это помогает уточнить, как работают атрибуты. Они представляют собой переменные с уникальными значениями для каждого экземпляра класса.

> **Примечание**: "Переменная экземпляра" в Python — это атрибут, который хранит данные, уникальные для каждого экземпляра конкретного класса. Такие переменные создаются в каждом новом объекте класса, что позволяет хранить индивидуальные значения для каждого объекта.

В нашем приложении для инвентаризации фруктов фермер может захотеть узнать, из какого сада пришел апельсин, когда его собрали и сколько он весит. Возможно, фермер также захочет отслеживать, где хранится каждая корзина. Яблоки могут иметь атрибут цвета, а бочки — быть разных размеров.

Некоторые из этих свойств могут принадлежать нескольким классам (мы можем захотеть узнать, когда были собраны и яблоки), но для нашего первого примера добавим несколько различных атрибутов в нашу диаграмму классов:

**Рисунок 1.3: Диаграмма классов с атрибутами**

В зависимости от того, насколько детализированным должно быть наше проектирование, мы также можем указать тип значения для каждого атрибута. В UML типы атрибутов часто представлены общими именами, понятными в большинстве языков программирования, например, целое число, число с плавающей точкой, строка, байт или логическое значение (Boolean). Однако типы могут также представлять общие коллекции, такие как списки, деревья или графы, или, что более важно, специфические для приложения классы.

> **Примечание**: На этапе проектирования UML может пересекаться с программированием, так как может возникнуть необходимость указать, какой тип данных будет использоваться. Основные примитивы и встроенные коллекции в одном языке программирования могут отличаться от других. Например, Java предлагает такие структуры, как `LinkedList` или `ArrayList`, тогда как в Python можно использовать `List[Apple]` в качестве подсказки типа и встроенный тип `list` для реализации.

Вот версия диаграммы с использованием (в основном) Python-специфичных подсказок типов:

**Рисунок 1.4: Диаграмма классов с атрибутами и их типами**

Обычно на этапе проектирования не требуется слишком много думать о типах данных, так как детали, связанные с реализацией, выбираются на этапе программирования. Общие названия типов обычно достаточно для проектирования; именно поэтому мы включили `date` как указатель на тип данных в Python, например, `datetime.datetime`. Если в проекте нужен тип контейнера "список", разработчики на Java могут выбрать `LinkedList` или `ArrayList`, а программисты на Python (то есть мы) могут использовать `List[Apple]` в качестве подсказки типа и тип `list` для реализации.

В нашем примере с фруктовой фермой все наши атрибуты являются простыми примитивами. Однако существуют некоторые **неявные атрибуты**, которые можно сделать явными — это связи. Для конкретного апельсина у нас есть атрибут, указывающий на корзину, в которой он хранится, — атрибут **basket** с подсказкой типа `Basket`.

> **Примечание**: "Связь" между объектами может быть представлена в виде атрибута, описывающего отношение между экземплярами классов. Например, атрибут `basket` указывает, в какой именно корзине находится данный апельсин.

## Поведение — это действия

Теперь, когда мы знаем, как данные определяют состояние объекта, последний нераскрытый термин, на который нам нужно обратить внимание, — это **поведение**. Поведение — это действия, которые могут выполняться над объектом. Поведение, которое может быть выполнено с определённым классом объектов, выражается в виде **методов** этого класса.

> **Примечание**: В объектно-ориентированном программировании **методы** — это функции, принадлежащие классу, которые имеют доступ к атрибутам объекта, особенно к переменным экземпляра, связанным с данными этого объекта. В отличие от функций в структурированном программировании, методы могут обращаться к состоянию конкретного экземпляра, что позволяет им выполнять действия, связанные именно с этим объектом.

На уровне программирования методы похожи на функции, но они имеют доступ к атрибутам — в частности, к переменным экземпляра, содержащим данные, связанные с этим объектом. Как и функции, методы могут принимать параметры и возвращать значения.

Параметры метода передаются ему в виде набора объектов, которые необходимо передать в метод. Конкретные экземпляры объектов, передаваемые в метод во время его вызова, обычно называются **аргументами**.

> **Примечание**: Параметры — это переменные, объявленные в определении метода, в которые во время вызова метода передаются конкретные объекты — аргументы.

Эти объекты связываются с переменными параметров в теле метода. Метод использует их для выполнения своего поведения или задачи. Возвращаемые значения являются результатом выполнения этой задачи. Внутренние изменения состояния также являются возможным результатом выполнения метода.

Мы уже расширили наш пример с яблоками и апельсинами, превратив его в основное (хотя и надуманное) приложение для инвентаризации. Давайте немного усложним его и посмотрим, не выйдет ли оно из-под контроля. Одним из действий, связанных с апельсинами, может быть действие **сбора** (pick). Если подумать об его реализации, сбор потребует выполнения двух задач:

- Поместить апельсин в корзину, обновив атрибут **Basket** апельсина.
- Добавить апельсин в список **Orange** данной корзины.

Таким образом, методу **pick** необходимо знать, с какой корзиной он работает. Мы делаем это, передавая корзину в качестве параметра метода **pick**. Поскольку наш фермер также продает сок, мы можем добавить метод **squeeze** (выжать) в класс **Orange**. При вызове метод **squeeze** может возвращать количество полученного сока, одновременно удаляя **Orange** из корзины, в которой он находился.

> **Примечание**: В объектно-ориентированном подходе передача параметров позволяет методам использовать другие объекты или данные для выполнения своих задач. В данном случае, передавая параметр **Basket** в метод **pick**, мы указываем корзину, с которой взаимодействует апельсин, добавляя гибкость и точность в наши операции.

Класс **Basket** может иметь действие **sell** (продать). Когда корзина продаётся, наша система инвентаризации может обновить некоторые данные на пока неопределённых объектах для расчётов учёта и прибыли. С другой стороны, корзина с апельсинами может испортиться, прежде чем её успеют продать, поэтому мы добавляем метод **discard** (выбросить). Добавим эти методы в нашу диаграмму:

**Рисунок 1.5: Диаграмма классов с атрибутами и методами**

Добавление атрибутов и методов к отдельным объектам позволяет нам создать систему взаимодействующих объектов. Каждый объект в системе принадлежит определённому классу. Эти классы определяют, какие типы данных может содержать объект и какие методы могут быть вызваны. Данные в каждом объекте могут находиться в разном состоянии по сравнению с другими экземплярами того же класса; каждый объект может по-разному реагировать на вызов методов из-за различий в состоянии.

Объектно-ориентированный анализ и проектирование посвящены тому, чтобы понять, какими должны быть эти объекты и как они должны взаимодействовать. Каждый класс имеет **ответственности** и **сотрудничество**.

> **Примечание**: Ответственности — это задачи, которые должны выполнять объекты каждого класса, а сотрудничество — это взаимодействие между классами. Определение этих аспектов является важной частью объектно-ориентированного проектирования.

Следующий раздел описывает принципы, которые можно использовать для того, чтобы сделать взаимодействия как можно более простыми и интуитивными.

Обратите внимание, что продажа корзины не обязательно является функцией класса **Basket**. Возможно, что некоторый другой класс (не показанный на диаграмме) "заботится" о различных корзинах и их местонахождении. В нашем проекте часто будут встречаться границы, определяющие области ответственности для разных классов. Иногда распределение обязанностей между классами может быть неочевидным, что заставит нас пересматривать (и перерисовывать) наши UML-диаграммы более одного раза, чтобы исследовать альтернативные варианты проектирования.

> **Примечание**: Определение границ ответственности — одна из сложных задач в объектно-ориентированном проектировании. Иногда это требует итеративного подхода, при котором несколько вариантов схемы разрабатываются и анализируются, чтобы найти наиболее удачное распределение обязанностей между классами.


# Сокрытие деталей и создание публичного интерфейса

Основная цель моделирования объекта в объектно-ориентированном проектировании — определить, каким будет публичный интерфейс этого объекта. **Интерфейс** — это набор атрибутов и методов, которые могут быть доступны другим объектам для взаимодействия с данным объектом. Другим объектам не нужно (а в некоторых языках даже не разрешается) иметь доступ к внутренней работе объекта.

> **Примечание**: Под **публичным интерфейсом** понимается тот набор методов и атрибутов, который доступен для взаимодействия другим объектам, не раскрывая при этом внутренние механизмы работы объекта. Публичный интерфейс позволяет контролировать, какие данные и поведение доступны извне.

Пример из реального мира — это телевизор. Наш интерфейс к телевизору — это пульт управления. Каждая кнопка на пульте представляет метод, который можно вызвать у объекта **телевизор**. Когда мы, как вызывающий объект, используем эти методы, нас не интересует, получает ли телевизор сигнал по кабелю, через спутниковую антенну или через интернет-устройство. Мы не заботимся о том, какие электронные сигналы посылаются для регулировки громкости или предназначен ли звук для динамиков или наушников. Если мы откроем телевизор, чтобы получить доступ к его внутренним компонентам, например, чтобы разделить сигнал между внешними динамиками и наушниками, то можем потерять гарантию.

Этот процесс скрытия реализации объекта называется **сокрытием информации**. Иногда его называют **инкапсуляцией**, но инкапсуляция — это более широкое понятие. Инкапсулированные данные не обязательно скрыты. Инкапсуляция буквально означает создание "капсулы" или оболочки вокруг атрибутов. Корпус телевизора инкапсулирует его состояние и поведение. Мы имеем доступ к внешнему экрану, динамикам и пульту, но не имеем прямого доступа к проводам усилителей или приёмникам внутри корпуса телевизора.

> **Примечание**: Сокрытие информации — это процесс, ограничивающий доступ к внутренней реализации объекта, чтобы внешние объекты могли взаимодействовать только через публичный интерфейс. Инкапсуляция охватывает этот процесс, но также включает концепцию обёртывания состояния и поведения в единое целое.

Когда мы покупаем комплексную аудиосистему, уровень инкапсуляции меняется, поскольку мы получаем доступ к интерфейсам между компонентами. Если мы занимаемся разработкой устройств для Интернета вещей, мы можем разобрать устройство на части и нарушить попытку производителя скрыть детали его реализации.

Различие между инкапсуляцией и сокрытием информации в основном несущественно, особенно на уровне проектирования. Многие практические источники используют эти термины взаимозаменяемо. Как программистам на Python, нам фактически не нужно и не требуется скрывать информацию с помощью полностью частных, недоступных переменных (причины этого мы обсудим в Главе 2, "Объекты в Python"), поэтому более широкое определение инкапсуляции является подходящим.

Публичный интерфейс, однако, очень важен. Его необходимо тщательно проектировать, так как его изменение может быть сложным, если от него зависят другие классы. Изменение интерфейса может нарушить работу любых клиентских объектов, которые на него полагаются. Мы можем изменить внутреннюю реализацию по своему усмотрению, например, чтобы сделать её более эффективной или чтобы получить доступ к данным как по сети, так и локально, и клиентские объекты всё равно смогут с ним взаимодействовать, не изменяясь, используя публичный интерфейс. С другой стороны, если мы изменим интерфейс, изменив публичные имена атрибутов или порядок и типы аргументов, которые может принимать метод, все клиентские классы также придётся изменить. Проектируя публичный интерфейс, придерживайтесь простоты. Всегда разрабатывайте интерфейс объекта, основываясь на его удобстве в использовании, а не на сложности его кодирования (этот совет также применим к пользовательским интерфейсам).

> **Примечание**: В Python переменные, начинающиеся с подчёркивания (`_`), сигнализируют, что они не являются частью публичного интерфейса. Этот символ подчёркивания является предупреждением для других программистов, что такие переменные лучше не использовать вне класса.

Помните, что объекты программы могут представлять реальные объекты, но это не делает их реальными. Они являются моделями. Одно из важнейших преимуществ моделирования — это возможность игнорировать несущественные детали. Модель автомобиля, которую один из авторов собрал в детстве, снаружи выглядела как настоящий Thunderbird 1956 года, но, конечно, она не могла ездить. Когда автор был слишком мал, чтобы водить машину, эти детали были слишком сложными и несущественными. Модель — это абстракция реальной концепции.

> **Примечание**: **Абстракция** — это ещё один термин, связанный с инкапсуляцией и сокрытием информации. Абстракция означает работу с уровнем деталей, наиболее подходящим для выполнения конкретной задачи. Это процесс выделения публичного интерфейса из внутренних деталей.

Для водителя автомобиля абстракция включает взаимодействие с рулем, педалью акселератора и тормозами. Работу двигателя, трансмиссии и тормозной системы водитель не видит. Механик, напротив, работает на другом уровне абстракции, регулируя двигатель и обслуживая тормоза. Вот пример двух уровней абстракции для автомобиля:

**Рисунок 1.6: Уровни абстракции для автомобиля**

Теперь у нас есть несколько новых терминов, которые обозначают похожие концепции. Давайте кратко подытожим: абстракция — это процесс инкапсуляции информации с помощью отдельного публичного интерфейса. Любые частные элементы могут быть скрыты, что и составляет сокрытие информации. В UML-диаграммах можно использовать символ `-` вместо `+`, чтобы показать, что элемент не является частью публичного интерфейса.

Главный урок, который следует извлечь из всех этих определений, — это сделать наши модели понятными для других объектов, которые должны с ними взаимодействовать. Это означает уделение особого внимания деталям.

Убедитесь, что методы и свойства имеют осмысленные названия. При анализе системы объекты обычно представляют собой существительные в исходной задаче, в то время как методы — это обычно глаголы. Атрибуты могут быть прилагательными или дополнительными существительными. Давайте названия вашим классам, атрибутам и методам в соответствии с этим правилом.

Проектируя интерфейс, представьте, что вы сами являетесь этим объектом; вам нужны чёткие определения ваших обязанностей, и вы предпочитаете максимально возможную приватность для выполнения этих обязанностей. Не позволяйте другим объектам получать доступ к вашим данным, если вы не считаете, что это в ваших интересах. Не предоставляйте им интерфейс для выполнения определенной задачи, если вы не уверены, что это именно ваша обязанность.


# Композиция

До сих пор мы научились проектировать системы как группу взаимодействующих объектов, где каждое взаимодействие подразумевает рассмотрение объектов на соответствующем уровне абстракции. Однако мы ещё не знаем, как создать эти уровни абстракции. Существует несколько способов достижения этой цели; некоторые продвинутые шаблоны проектирования мы обсудим в главах 10, 11 и 12. Но даже большинство шаблонов проектирования опираются на два основных принципа объектно-ориентированного программирования, известных как **композиция** и **наследование**. Композиция проще, поэтому начнём с неё.

**Композиция** — это объединение нескольких объектов для создания нового. Композиция обычно является хорошим выбором, когда один объект является частью другого объекта.

> **Примечание**: Композиция позволяет создавать объекты, объединяя их компоненты. Это позволяет создавать иерархии и уровни абстракции, предоставляя более высокоуровневые интерфейсы для различных пользователей и позволяя скрывать детали внутреннего устройства.

Мы уже видели первый намёк на композицию, когда говорили об автомобилях. Автомобиль с двигателем внутреннего сгорания состоит из двигателя, трансмиссии, стартера, фар и лобового стекла, наряду с множеством других деталей. В свою очередь, двигатель состоит из поршней, коленчатого вала и клапанов. В этом примере композиция — хороший способ создания уровней абстракции. Объект **автомобиль** может предоставлять интерфейс, необходимый водителю, одновременно предоставляя доступ к его компонентам, что обеспечивает более глубокий уровень абстракции, подходящий для механика. Эти компоненты могут быть, конечно, далее разделены на ещё более мелкие детали, если механику потребуется больше информации для диагностики проблемы или настройки двигателя.

Автомобиль — это распространённый начальный пример композиции, но он не слишком полезен при проектировании компьютерных систем. Физические объекты легко разделить на составные части. Люди делают это с древности, ещё со времён греков, которые считали, что атомы — это мельчайшие частицы материи (у них, конечно, не было доступа к ускорителям частиц). В компьютерных системах, однако, определение составных объектов не происходит так же естественно, как с реальными клапанами и поршнями.

Объекты в объектно-ориентированной системе иногда представляют физические объекты, такие как люди, книги или телефоны. Однако чаще они представляют собой концепции. Люди имеют имена, книги имеют названия, а телефоны используются для совершения звонков. Звонки, названия, учётные записи, имена, встречи и платежи не всегда воспринимаются как объекты в физическом мире, но они часто моделируются как компоненты в компьютерных системах.

Давайте попробуем смоделировать более компьютерно-ориентированный пример, чтобы увидеть композицию в действии. Мы рассмотрим проектирование компьютерной игры в шахматы. Это было очень популярное развлечение в 80-х и 90-х годах. Люди предсказывали, что компьютеры однажды смогут обыграть шахматного мастера. Когда это произошло в 1997 году (компьютер IBM Deep Blue победил чемпиона мира по шахматам Гарри Каспарова), интерес к шахматной задаче поубавился. В наши дни потомки Deep Blue всегда выигрывают.

Шахматная партия играется между двумя игроками, используя шахматный набор с доской, состоящей из 64 позиций в сетке 8×8. На доске можно разместить два набора из 16 фигур, которые могут двигаться, поочередно делая ходы двумя игроками разными способами. Каждая фигура может брать другие фигуры. После каждого хода доска должна отображаться на экране компьютера.

> **Примечание**: Мы выделили некоторые из возможных объектов в описании курсивом, а несколько ключевых методов — жирным шрифтом. Это распространённый первый шаг при превращении объектно-ориентированного анализа в проектирование.

На этом этапе, чтобы подчеркнуть композицию, мы сосредоточимся на доске, не вдаваясь в детали игроков и различных типов фигур.

Начнем с самого высокого уровня абстракции. У нас есть два игрока, взаимодействующих с шахматным набором, поочередно совершая ходы:

**Рисунок 1.7: Диаграмма объектов/экземпляров для шахматной игры**

Это выглядит не совсем так, как наши предыдущие диаграммы классов, и это хорошо, потому что это не она! Это **диаграмма объектов**, также называемая **диаграммой экземпляров**. Она описывает систему в определённом состоянии времени и отображает конкретные экземпляры объектов, а не взаимодействие между классами. Помните, что оба игрока принадлежат к одному классу, поэтому диаграмма классов выглядит немного иначе:

**Рисунок 1.8: Диаграмма классов для шахматной игры**

Эта диаграмма показывает, что ровно два игрока могут взаимодействовать с одним шахматным набором. Она также указывает, что любой игрок может играть только с одним шахматным набором одновременно. Однако мы обсуждаем композицию, а не UML, поэтому давайте подумаем, из чего состоит шахматный набор. Нам не важно, из чего состоит игрок на данный момент. Мы можем предположить, что у него есть сердце и мозг, наряду с другими органами, но это не имеет значения для нашей модели. На самом деле, ничто не мешает представить игрока в виде самого Deep Blue, у которого нет ни сердца, ни мозга.

Шахматный набор, таким образом, состоит из доски и 32 фигур. Доска, в свою очередь, состоит из 64 позиций. Можно утверждать, что эти фигуры не являются частью шахматного набора, так как их можно заменить на другой набор фигур. Хотя это маловероятно или невозможно в компьютерной версии шахмат, этот момент подводит нас к понятию **агрегации**.

> **Примечание**: **Агрегация** почти идентична композиции. Различие заключается в том, что агрегированные объекты могут существовать независимо. Например, позицию нельзя связать с другой шахматной доской, поэтому мы говорим, что доска состоит из позиций. Однако фигуры, которые могут существовать отдельно от шахматного набора, находятся с ним в агрегатной связи.

Другой способ отличить агрегацию от композиции — это рассмотреть продолжительность существования объекта:
- Если внешний (составной) объект управляет созданием и уничтожением связанных (внутренних) объектов, композиция будет наиболее подходящей.
- Если связанный объект создается независимо от составного объекта или может пережить его, агрегатная связь более уместна.

> **Примечание**: Также важно помнить, что композиция является разновидностью агрегации; агрегация — это более общий вид композиции. Любая композиционная связь также является агрегатной, но не наоборот.

Опишем текущую композицию шахматного набора и добавим атрибуты к объектам, чтобы отразить их составные связи:

**Рисунок 1.9: Диаграмма классов для шахматной игры**

Композиционная связь представлена в UML как сплошной ромб. Пустой ромб представляет агрегатную связь. Вы заметите, что доска и фигуры хранятся как часть шахматного набора точно так же, как ссылка на них хранится как атрибут в шахматном наборе. Это показывает, что, как и в других случаях, на практике различие между агрегацией и композицией часто не имеет значения, как только вы перейдете от стадии проектирования к реализации. При реализации они ведут себя практически одинаково.

Это различие может помочь вам отличить их друг от друга, когда ваша команда обсуждает, как взаимодействуют разные объекты. Часто вам нужно различать их, когда речь идет о продолжительности существования связанных объектов. В большинстве случаев удаление составного объекта (например, доски) приведёт к удалению всех его позиций. Агрегированные объекты, однако, не удаляются автоматически.


# Наследование

Мы обсудили три типа отношений между объектами: ассоциацию, композицию и агрегацию. Однако мы ещё не полностью определили наш шахматный набор, и этих инструментов недостаточно для решения всех задач. Мы рассматривали возможность, что игрок может быть человеком или программой с искусственным интеллектом. Нелогично утверждать, что игрок связан с человеком или что реализация искусственного интеллекта является частью объекта игрока. На самом деле нам нужно сказать, что Deep Blue — это игрок или что Гарри Каспаров — это игрок.

Отношение "является" (is a) формируется с помощью наследования. Наследование — это самый известный и, возможно, чрезмерно используемый тип отношения в объектно-ориентированном программировании. Наследование похоже на генеалогическое древо: например, Dusty Phillips — один из авторов этой книги, унаследовал фамилию Phillips от своего отца, который, в свою очередь, унаследовал её от своего отца. В объектно-ориентированном программировании, вместо того чтобы наследовать черты и поведение человека, один класс может наследовать атрибуты и методы от другого класса.

> **Примечание**: В объектно-ориентированном подходе наследование позволяет классу (называемому дочерним или подклассом) перенимать свойства и поведение другого класса (родительского или базового). Это позволяет организовать иерархию классов, уменьшая дублирование кода и обеспечивая гибкость в расширении функциональности.

Например, в нашем шахматном наборе есть 32 фигуры, но только шесть типов фигур (пешки, ладьи, слоны, кони, король и ферзь), каждая из которых ведёт себя по-разному при перемещении. Все эти классы фигур имеют общие свойства, такие как цвет и принадлежность к шахматному набору, но у каждой есть уникальная форма, которая отображается на доске, и разные правила для движения. Посмотрим, как шесть типов фигур могут наследоваться от класса **Piece**:

**Рисунок 1.10: Наследование шахматных фигур от класса Piece**

Пустые стрелки указывают, что отдельные классы фигур наследуются от класса **Piece**. Все дочерние классы автоматически имеют атрибуты **chess_set** и **color**, унаследованные от базового класса. Каждая фигура предоставляет свою форму (для отображения на экране при рендеринге доски) и свой метод **move**, чтобы перемещать фигуру на новую позицию на доске после каждого хода.

Мы знаем, что всем подклассам класса **Piece** нужен метод **move**; в противном случае, когда доска попытается передвинуть фигуру, возникнет ошибка. Возможно, мы захотим создать новую версию шахматной игры, добавив дополнительную фигуру (например, волшебника). Наша текущая модель позволит нам создать эту фигуру, не определив для неё метод **move**. Тогда при попытке доски переместить фигуру возникнет сбой.

> **Примечание**: Чтобы избежать таких ситуаций, мы можем создать "пустой" метод **move** в базовом классе **Piece**, который можно будет переопределить в подклассах. Таким образом, базовая версия метода может выводить сообщение об ошибке, говорящее, что данную фигуру перемещать нельзя.

Переопределение методов в подклассах позволяет создавать мощные объектно-ориентированные системы. Например, если мы хотим реализовать класс **Player** с искусственным интеллектом, мы можем добавить метод **calculate_move**, который принимает объект **Board** и решает, какую фигуру куда переместить. Базовый класс может выбирать случайную фигуру и направление для её перемещения. Затем мы можем переопределить этот метод в подклассе с реализацией Deep Blue. Первый класс подойдёт для игры с новичком, а второй — для вызова гроссмейстеру. Важный момент заключается в том, что другие методы класса, такие как те, которые информируют доску о выбранном ходе, можно не изменять; это поведение может быть разделено между обоими классами.

В случае с шахматными фигурами создание стандартной реализации метода **move** не имеет смысла. Всё, что нам нужно сделать, — это потребовать, чтобы метод **move** был реализован в любом дочернем классе. Это можно сделать, сделав **Piece** абстрактным классом с объявленным абстрактным методом **move**.

> **Примечание**: **Абстрактные методы** — это методы, которые требуют реализации в любых не-абстрактных подклассах, но не содержат реализации в базовом классе. Такой метод как бы говорит: "Мы требуем, чтобы этот метод существовал в любом не-абстрактном подклассе, но мы не определяем его реализацию в этом классе."

На самом деле можно создать абстракцию, которая вообще не реализует ни одного метода. Такой класс лишь указывает, что должен делать класс, но не даёт никаких указаний, как это делать. В некоторых языках такие полностью абстрактные классы называются **интерфейсами**. В Python также можно создать класс, содержащий только абстрактные методы, но это используется довольно редко.

> **Примечание**: Интерфейсы, как правило, описывают поведение, которое должен реализовать класс, но не содержат конкретной реализации. В Python этот функционал достигается с помощью абстрактных классов, которые могут содержать методы-заглушки для будущей реализации.


## Наследование обеспечивает абстракцию

Рассмотрим одно из самых длинных слов в объектно-ориентированном лексиконе: **полиморфизм**. Полиморфизм — это возможность по-разному обрабатывать класс в зависимости от того, какой подкласс реализован. Мы уже видели это на примере системы с шахматными фигурами. Если мы углубим дизайн, то увидим, что объект **Board** может принять ход от игрока и вызвать метод **move** для фигуры. Доске никогда не нужно знать, с каким типом фигуры она имеет дело. Всё, что нужно сделать, — это вызвать метод **move**, и правильный подкласс позаботится о том, чтобы передвинуть фигуру как коня или пешку.

> **Примечание**: **Полиморфизм** позволяет объектам одного класса вести себя по-разному в зависимости от того, к какому подклассу они принадлежат. Это создаёт гибкость при проектировании, так как позволяет использовать единый интерфейс для различных типов объектов.

Полиморфизм — это круто, но слово это редко используется в программировании на Python. Python идет дальше, позволяя обращаться с объектами так, как будто они являются экземплярами родительского класса, даже если это не так. Доска, реализованная на Python, может принять любой объект, имеющий метод **move** — будь то фигура слона, автомобиль или утка. Когда вызывается метод **move**, слон будет перемещаться по диагонали на доске, автомобиль поедет куда-то, а утка поплывет или полетит, в зависимости от её настроения.

Этот вид полиморфизма в Python обычно называется **утиная типизация** (duck typing): "если он ходит как утка и плавает как утка, мы называем его уткой". Нас не волнует, является ли это действительно уткой (является — это основа наследования), важно лишь, чтобы объект умел плавать или ходить. Гуси и лебеди также могут предоставить поведение, похожее на утиное.

> **Примечание**: Утиная типизация позволяет нам работать с объектами на основе их поведения, а не типа. Это открывает возможности для создания новых типов объектов, не используя жёсткую иерархию классов, как в традиционном наследовании.

Этот подход позволяет будущим разработчикам создавать новые типы птиц, не создавая формальную иерархию наследования для всех возможных видов водоплавающих птиц. В примерах с шахматами выше использовалось формальное наследование для покрытия всех возможных фигур в шахматном наборе. Утиная типизация также позволяет программисту расширять дизайн, создавая совершенно другие виды поведения, которые не были предусмотрены изначально. Например, в будущем разработчики могут создать пингвина, который ходит и плавает, совместимого с тем же интерфейсом, не предполагая, что у пингвинов есть общий родительский класс с утками.

## Множественное наследование

Когда мы думаем о наследовании в нашем собственном генеалогическом древе, мы видим, что наследуем черты не только от одного родителя. Когда посторонние говорят гордой матери, что у её сына глаза отца, она обычно отвечает: "Да, но нос у него от меня."

В объектно-ориентированном дизайне также может использоваться **множественное наследование**, которое позволяет подклассу наследовать функциональность сразу от нескольких родительских классов. На практике множественное наследование может быть сложной задачей, и некоторые языки программирования (самый известный из них — Java) строго запрещают его. Однако множественное наследование может быть полезным. Чаще всего оно используется для создания объектов с двумя различными наборами поведения. Например, объект, предназначенный для подключения к сканеру для создания изображения и отправки факса с отсканированным изображением, можно создать с наследованием от двух отдельных классов сканера и факсимильного аппарата.

> **Примечание**: Множественное наследование позволяет классу унаследовать поведение сразу от нескольких классов, что полезно для создания объектов со смешанными функциональностями. Однако это может привести к путанице, если классы имеют пересекающиеся интерфейсы.

Пока у двух классов различный интерфейс, обычно нет ничего вредного в том, чтобы подкласс наследовал оба из них. Однако ситуация становится сложной, если мы наследуем два класса, которые предоставляют пересекающиеся интерфейсы. У сканера и факса нет общих функций, поэтому их можно легко объединить. Противоположный пример — класс **мотоцикл**, у которого есть метод **move**, и класс **лодка**, также содержащий метод **move**.

Если мы хотим объединить их в универсальное амфибийное транспортное средство, как результатирующий класс поймёт, что делать при вызове **move**? На уровне проектирования это необходимо объяснить. (Как моряк, один из авторов, живший на лодке, действительно хочет понять, как это должно работать.)

> **Примечание**: Python имеет определённый порядок разрешения методов (MRO — Method Resolution Order), который помогает понять, какой из альтернативных методов будет использоваться. Хотя правила MRO просты, избежать пересечения интерфейсов ещё проще.

Множественное наследование как техника "миксинов" для объединения различных аспектов может быть полезно. Однако в большинстве случаев объект-композиция может оказаться легче в проектировании.

Наследование — это мощный инструмент для расширения поведения и повторного использования функций. Это одно из самых заметных преимуществ объектно-ориентированного дизайна перед более ранними парадигмами. Поэтому часто это первый инструмент, к которому обращаются программисты, работающие с объектами. Однако важно помнить, что наличие молотка не превращает винты в гвозди. Наследование — идеальное решение для очевидных отношений "является" (is a). В других случаях оно может быть неправильно использовано. Программисты часто используют наследование для совместного использования кода между двумя видами объектов, которые только отдаленно связаны, и между которыми нет отношения "является". Хотя это не обязательно плохой дизайн, это отличный повод задуматься, почему они решили проектировать именно так, и не подошло бы ли лучшее отношение или другой шаблон проектирования.