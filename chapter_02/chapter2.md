# Объекты в Python

У нас есть дизайн, и мы готовы превратить его в работающую программу! Конечно, обычно всё происходит немного по-другому. На протяжении книги мы будем видеть примеры и подсказки по хорошему проектированию программного обеспечения, но наш основной фокус — объектно-ориентированное программирование. Итак, давайте посмотрим на синтаксис Python, который позволяет создавать объектно-ориентированное ПО.

После завершения этой главы вы поймете следующее:

- Как использовать *подсказки типов* в Python.
- Как создавать классы и экземпляры объектов в Python.
- Как организовывать классы в пакеты и модули.
- Как показать пользователям, что они не должны изменять данные объекта, нарушая его внутреннее состояние.
- Как работать с сторонними пакетами, доступными в *индексе пакетов Python* (Python Package Index, PyPI).

Эта глава также продолжит наше практическое задание, углубившись в проектирование некоторых классов.

### Введение в подсказки типов

Прежде чем мы сможем подробно рассмотреть создание классов, нам нужно немного поговорить о том, что такое класс и как убедиться, что мы используем его правильно. Ключевая идея заключается в том, что **в Python всё является объектом**.

Когда мы записываем такие значения, как `"Hello, world!"` или `42`, на самом деле мы создаем экземпляры встроенных классов. Мы можем запустить интерактивный режим Python и использовать встроенную функцию `type()` для определения класса, который определяет свойства этих объектов:

```python
>>> type("Hello, world!")
<class 'str'>
>>> type(42)
<class 'int'>
```

> **Примечание:** Функция `type()` используется для получения типа объекта, т.е. определения класса, которому принадлежит объект.

Основная идея объектно-ориентированного программирования — решать задачи с помощью взаимодействия объектов. Когда мы пишем `6*7`, умножение двух объектов обрабатывается методом встроенного класса `int`. Для более сложных действий нам часто требуется создавать уникальные, новые классы.

Вот первые два основных правила, как работают объекты в Python:

1. **Всё в Python является объектом.**
2. **Каждый объект определяется как экземпляр по крайней мере одного класса.**

> **Примечание:** *Экземпляр класса* — это конкретный объект, созданный по "чертежу" класса. Класс определяет свойства и поведение объекта.

Эти правила имеют множество интересных последствий. Определение класса, которое мы пишем с помощью оператора `class`, создает новый объект типа `type`. Когда мы создаем экземпляр класса, объект класса используется для создания и инициализации объекта экземпляра.

> **Примечание:** Отличие между классом и типом заключается в том, что оператор `class` позволяет нам определять новые типы. Мы будем называть их классами, так как используем `class` для их создания. В статье "Python objects, types, classes, and instances - a glossary" (Eli Bendersky) подчеркивается, что термины *класс* и *тип* часто взаимозаменяемы.

Мы будем называть аннотации *подсказками типов*.

### Еще одно важное правило:

- **Переменная — это ссылка на объект.** Представьте желтую липкую бумажку с написанным именем, наклеенную на объект.

> **Примечание:** Это означает, что информация о типе — то, что представляет собой объект — определяется классом (или классами), связанными с объектом. Эта информация о типе не привязана к переменной напрямую.

Это правило позволяет писать следующий, хоть и сбивающий с толку, но корректный код на Python:

```python
>>> a_string_variable = "Hello, world!"
>>> type(a_string_variable)
<class 'str'>
>>> a_string_variable = 42
>>> type(a_string_variable)
<class 'int'>
```

> **Примечание:** Мы создали объект с использованием встроенного класса `str`, присвоив ему имя `a_string_variable`. Затем мы создали объект с использованием встроенного класса `int` и присвоили ему то же имя. Ранее созданный объект строки больше не имеет ссылок и перестаёт существовать.

Вот эти два шага, показанные рядом, показывают, как переменная перемещается от объекта к объекту:

**Рисунок 2.1: Имена переменных и объекты**

Свойства являются частью объекта, а не переменной. Когда мы проверяем тип переменной с помощью `type()`, мы видим тип объекта, на который переменная ссылается в данный момент. У переменной нет собственного типа; это всего лишь имя. Аналогично, вызов `id()` переменной показывает идентификатор объекта, на который указывает переменная. Поэтому имя `a_string_variable` становится немного сбивающим с толку, если мы присваиваем ему объект целого числа.

> **Примечание:** Метод `id()` возвращает уникальный идентификатор объекта, на который указывает переменная.

# Проверка типов

Давайте углубим отношения между объектом и типом и рассмотрим еще некоторые следствия этих правил. Вот определение функции:

```python
>>> def odd(n):
...     return n % 2 != 0
>>> odd(3)
True
>>> odd(4)
False
```

Эта функция выполняет небольшое вычисление с переменной `n`. Она вычисляет остаток от деления (операцию *модуля*). Если мы делим нечётное число на два, остаётся остаток один. Если мы делим чётное число на два, остаток равен нулю. Функция возвращает `True` для всех нечётных чисел.

Что произойдет, если мы передадим не число? Давайте попробуем и посмотрим, что получится (часто так изучают Python!). В интерактивном режиме Python мы получим что-то вроде этого:

```python
>>> odd("Hello, world!")
Traceback (most recent call last):
  File "<doctestexamples.md[9]>", line 1, in <module>
    odd("Hello, world!")
  File "<doctestexamples.md[6]>", line 2, in odd
    return n % 2 != 0
TypeError: not all arguments converted during string formatting
```

> **Примечание:** Это важное следствие гибких правил Python: ничего не мешает нам сделать что-то некорректное, что может вызвать исключение. Python не мешает нам пытаться использовать методы, которых может не быть у объекта.

В нашем примере оператор `%`, предоставляемый классом `str`, работает иначе, чем оператор `%`, предоставляемый классом `int`, вызывая исключение. В строках оператор `%` используется для интерполяции (например, `"a=%d" % 113` создаёт строку `'a=113'`). Если слева нет спецификации формата, такой как `%d`, возникает ошибка `TypeError`. Для целых чисел `%` вычисляет остаток от деления (например, `355 % 113` возвращает 16).

> **Примечание:** Гибкость Python — это осознанный компромисс, отдающий предпочтение простоте использования перед сложными мерами предосторожности. Это позволяет разработчику использовать переменные с минимальной нагрузкой на память.

Python проверяет операнды оператора во время выполнения, но наша функция не включает проверку типа в рантайме, и мы не хотим добавлять код для проверки типов во время выполнения. Вместо этого мы используем инструменты для анализа кода в процессе тестирования. Мы можем предоставить аннотации, называемые *подсказками типов*, и использовать инструменты для проверки согласованности типов в коде.

Сначала давайте взглянем на аннотации. В нескольких контекстах можно поставить двоеточие `:` и указать тип после имени переменной. Это можно делать в параметрах функции (и методов), а также в операторе присваивания. Более того, мы можем добавить `->` после определения функции (или метода класса), чтобы указать предполагаемый тип возвращаемого значения.

Пример того, как выглядят подсказки типов:

```python
>>> def odd(n: int) -> bool:
...     return n % 2 != 0
```

> **Примечание:** В этом примере мы добавили две подсказки типов к функции `odd()`. Мы указали, что аргументы для параметра `n` должны быть целыми числами (`int`). Мы также указали, что результат будет одного из двух значений типа `bool` (логического типа).

Подсказки занимают немного памяти, но не влияют на выполнение. Python игнорирует их во время выполнения, так что они остаются необязательными. Но тем, кто читает ваш код, они будут полезны, поскольку передают ваши намерения. Пока вы учитесь, их можно не указывать, но в будущем они упростят понимание и расширение кода.

Для проверки подсказок на согласованность обычно используется инструмент **mypy**. Он не встроен в Python и требует отдельной установки. Чтобы установить его, можно использовать команду `python -m pip install mypy` или `conda install mypy`, если вы используете `conda`.

Допустим, у нас есть файл `bad_hints.py` в каталоге `src` с двумя функциями и несколькими строками для вызова функции `main()`:

```python
def odd(n: int) -> bool:
    return n % 2 != 0

def main():
    print(odd("Hello, world!"))

if __name__ == "__main__":
    main()
```

Когда мы запускаем команду mypy в терминале:

```shell
% mypy –strict src/bad_hints.py
```

Инструмент mypy обнаружит несколько потенциальных проблем, среди которых, как минимум, следующие:

- **Ошибка 1:** Функция `main()` не имеет аннотации типа возвращаемого значения; mypy предлагает включить `-> None`, чтобы явно указать отсутствие возвращаемого значения.
  
- **Ошибка 2:** Код пытается передать строку (`str`) в функцию `odd()`, которая ожидает целое число (`int`), что указывает на возможную ошибку.

Большинство примеров в этой книге будут содержать подсказки типов, так как они всегда полезны, особенно для обучения, хотя и остаются необязательными. Поскольку Python в основном является типонезависимым, существуют случаи, когда поведение сложно описать с помощью краткой, понятной подсказки.

> **Примечание:** Предложение по улучшению Python (Python Enhancement Proposal, PEP) 585 содержит несколько новых функций языка, упрощающих подсказки типов. Мы использовали версию mypy 0.812 для тестирования всех примеров в этой книге.

# Проверка типов

Давайте углубим отношения между объектом и типом и рассмотрим еще некоторые следствия этих правил. Вот определение функции:

```python
>>> def odd(n):
...     return n % 2 != 0
>>> odd(3)
True
>>> odd(4)
False
```

Эта функция выполняет небольшое вычисление с переменной `n`. Она вычисляет остаток от деления (операцию *модуля*). Если мы делим нечётное число на два, остаётся остаток один. Если мы делим чётное число на два, остаток равен нулю. Функция возвращает `True` для всех нечётных чисел.

Что произойдет, если мы передадим не число? Давайте попробуем и посмотрим, что получится (часто так изучают Python!). В интерактивном режиме Python мы получим что-то вроде этого:

```python
>>> odd("Hello, world!")
Traceback (most recent call last):
  File "<doctestexamples.md[9]>", line 1, in <module>
    odd("Hello, world!")
  File "<doctestexamples.md[6]>", line 2, in odd
    return n % 2 != 0
TypeError: not all arguments converted during string formatting
```

> **Примечание:** Это важное следствие гибких правил Python: ничего не мешает нам сделать что-то некорректное, что может вызвать исключение. Python не мешает нам пытаться использовать методы, которых может не быть у объекта.

В нашем примере оператор `%`, предоставляемый классом `str`, работает иначе, чем оператор `%`, предоставляемый классом `int`, вызывая исключение. В строках оператор `%` используется для интерполяции (например, `"a=%d" % 113` создаёт строку `'a=113'`). Если слева нет спецификации формата, такой как `%d`, возникает ошибка `TypeError`. Для целых чисел `%` вычисляет остаток от деления (например, `355 % 113` возвращает 16).

> **Примечание:** Гибкость Python — это осознанный компромисс, отдающий предпочтение простоте использования перед сложными мерами предосторожности. Это позволяет разработчику использовать переменные с минимальной нагрузкой на память.

Python проверяет операнды оператора во время выполнения, но наша функция не включает проверку типа в рантайме, и мы не хотим добавлять код для проверки типов во время выполнения. Вместо этого мы используем инструменты для анализа кода в процессе тестирования. Мы можем предоставить аннотации, называемые *подсказками типов*, и использовать инструменты для проверки согласованности типов в коде.

Сначала давайте взглянем на аннотации. В нескольких контекстах можно поставить двоеточие `:` и указать тип после имени переменной. Это можно делать в параметрах функции (и методов), а также в операторе присваивания. Более того, мы можем добавить `->` после определения функции (или метода класса), чтобы указать предполагаемый тип возвращаемого значения.

Пример того, как выглядят подсказки типов:

```python
>>> def odd(n: int) -> bool:
...     return n % 2 != 0
```

> **Примечание:** В этом примере мы добавили две подсказки типов к функции `odd()`. Мы указали, что аргументы для параметра `n` должны быть целыми числами (`int`). Мы также указали, что результат будет одного из двух значений типа `bool` (логического типа).

Подсказки занимают немного памяти, но не влияют на выполнение. Python игнорирует их во время выполнения, так что они остаются необязательными. Но тем, кто читает ваш код, они будут полезны, поскольку передают ваши намерения. Пока вы учитесь, их можно не указывать, но в будущем они упростят понимание и расширение кода.

Для проверки подсказок на согласованность обычно используется инструмент **mypy**. Он не встроен в Python и требует отдельной установки. Чтобы установить его, можно использовать команду `python -m pip install mypy` или `conda install mypy`, если вы используете `conda`.

Допустим, у нас есть файл `bad_hints.py` в каталоге `src` с двумя функциями и несколькими строками для вызова функции `main()`:

```python
def odd(n: int) -> bool:
    return n % 2 != 0

def main():
    print(odd("Hello, world!"))

if __name__ == "__main__":
    main()
```

Когда мы запускаем команду mypy в терминале:

```shell
% mypy –strict src/bad_hints.py
```

Инструмент mypy обнаружит несколько потенциальных проблем, среди которых, как минимум, следующие:

- **Ошибка 1:** Функция `main()` не имеет аннотации типа возвращаемого значения; mypy предлагает включить `-> None`, чтобы явно указать отсутствие возвращаемого значения.
  
- **Ошибка 2:** Код пытается передать строку (`str`) в функцию `odd()`, которая ожидает целое число (`int`), что указывает на возможную ошибку.

Большинство примеров в этой книге будут содержать подсказки типов, так как они всегда полезны, особенно для обучения, хотя и остаются необязательными. Поскольку Python в основном является типонезависимым, существуют случаи, когда поведение сложно описать с помощью краткой, понятной подсказки.

> **Примечание:** Предложение по улучшению Python (Python Enhancement Proposal, PEP) 585 содержит несколько новых функций языка, упрощающих подсказки типов. Мы использовали версию mypy 0.812 для тестирования всех примеров в этой книге.


# Создание классов в Python

В **Предложении по улучшению Python** (*Python Enhancement Proposal*, PEP) 585 описаны новые функции языка, которые упрощают подсказки типов. Мы использовали версию mypy 0.812 для тестирования всех примеров в этой книге. Любая более старая версия может столкнуться с проблемами с некоторыми новыми синтаксическими конструкциями и техниками аннотирования.

Теперь, когда мы поговорили о том, как параметры и атрибуты описываются с помощью подсказок типов, давайте создадим несколько классов.

### Создание классов в Python

Python — это чистый и лаконичный язык. Чтобы выполнить задачу, нам не нужно писать много кода. Как вы, вероятно, видели, написание программы "Hello, world!" в Python — это всего одна строка.

Точно так же самый простой класс в Python 3 выглядит так:

```python
class MyFirstClass:
    pass
```

Это наша первая объектно-ориентированная программа! Определение класса начинается с ключевого слова `class`. Затем следует имя класса (выбранное нами) и двоеточие.

> **Примечание:** Имя класса должно соответствовать стандартным правилам именования переменных Python (начинаться с буквы или символа подчеркивания и содержать только буквы, цифры или символы подчеркивания). Кроме того, согласно стилевому руководству Python (*Python Enhancement Proposal 8*, или PEP 8), классы следует называть в стиле *CapWords*, то есть с заглавной буквы, и каждое последующее слово также должно начинаться с заглавной буквы.

> **Примечание:** *PEP 8* — это стиль и соглашения, принятые в Python для написания кода, обеспечивающие единообразие и читаемость. Например, в нем рекомендуется использовать отступы в четыре пробела, если нет веской причины для другого выбора, например, соответствия коду, использующему табуляцию для отступов.

Содержимое класса следует за строкой определения и отделяется отступами. Как и в других конструкциях Python, отступы используются для разграничения блоков кода, а не скобки или ключевые слова, как во многих других языках. 

Так как наш первый класс не добавляет никаких данных или поведения, мы просто используем ключевое слово `pass` на второй строке в качестве заполнителя, чтобы указать, что никаких дополнительных действий не требуется.

### Создание экземпляров класса

Может показаться, что с этим базовым классом нечего делать, но он позволяет нам создавать объекты этого класса. Мы можем загрузить класс в интерпретатор Python 3 и поработать с ним в интерактивном режиме. Чтобы это сделать, сохраните определение класса в файле с именем `first_class.py`, а затем выполните команду `python -i first_class.py`. Аргумент `-i` говорит Python запустить код, а затем перейти в интерактивный режим. 

В следующем сеансе интерпретатора показано основное взаимодействие с этим классом:

```python
>>> a = MyFirstClass()
>>> b = MyFirstClass()
>>> print(a)
<__main__.MyFirstClass object at 0xb7b7faec>
>>> print(b)
<__main__.MyFirstClass object at 0xb7b7fbac>
```

Эти строки создают два объекта из нового класса, присваивая им имена переменных `a` и `b`. Создание экземпляра класса состоит в записи имени класса, за которым следуют круглые скобки. Это выглядит как вызов функции; вызов класса создаёт новый объект.

> **Примечание:** При выводе на экран объекты показывают, к какому классу они принадлежат, и указывают на адрес памяти, в котором они находятся. Адреса памяти редко используются в Python-коде, но здесь они показывают, что речь идет о двух разных объектах.

Мы можем убедиться, что это два разных объекта, используя оператор `is`:

```python
>>> a is b
False
```

> **Примечание:** Оператор `is` проверяет, указывают ли две переменные на один и тот же объект в памяти. В данном случае результат `False` указывает на то, что `a` и `b` — два разных объекта.

Эта проверка помогает избежать путаницы, если мы создаем множество объектов и присваиваем им разные имена переменных.


# Добавление атрибутов

Теперь у нас есть базовый класс, но он довольно бесполезен. Он не содержит данных и не выполняет никаких действий. Что нужно сделать, чтобы присвоить объекту атрибут?

На самом деле, нам не нужно делать ничего особенного в определении класса, чтобы добавлять атрибуты. Мы можем установить произвольные атрибуты для экземпляра объекта, используя *точечную нотацию*. Вот пример:

```python
class Point:
    pass

p1 = Point()
p2 = Point()

p1.x = 5
p1.y = 4

p2.x = 3
p2.y = 6

print(p1.x, p1.y)
print(p2.x, p2.y)
```

Если запустить этот код, два оператора `print` в конце покажут значения новых атрибутов для двух объектов:

```
5 4
3 6
```

> **Примечание:** Этот код создает пустой класс `Point` без данных и поведения. Затем он создает два экземпляра этого класса и присваивает каждому из этих экземпляров координаты `x` и `y`, чтобы определить точку в двумерном пространстве. Чтобы присвоить значение атрибуту объекта, достаточно использовать синтаксис `<объект>.<атрибут> = <значение>`. Эта запись и называется *точечной нотацией*.

Значением атрибута может быть что угодно: базовый тип Python, встроенный тип данных или другой объект. Он может даже быть функцией или другим классом!

### Совместимость с проверкой типов

Создание атрибутов таким образом может запутать инструмент **mypy**, который проверяет типы данных. Для него нет простого способа включить подсказки типов в определение класса `Point`. Мы можем добавить подсказки в строки присваивания, например, так: `p1.x: float = 5`.

> **Примечание:** *mypy* — это инструмент для статической проверки типов в Python, который помогает выявить потенциальные ошибки типов еще до выполнения программы. Например, если переменной присвоен один тип данных, но в коде встречаются попытки использовать ее как другой тип, *mypy* выдаст предупреждение или ошибку.

Однако в целом существует более подходящий способ добавлять подсказки типов и атрибуты, о котором мы поговорим позже в разделе *Инициализация объекта* в этой главе. Сначала, однако, добавим поведение в наше определение класса.

# Придание функциональности

Итак, у нас есть объекты с атрибутами, и это прекрасно, но объектно-ориентированное программирование действительно ориентировано на взаимодействие между объектами. Нас интересует выполнение действий, которые могут повлиять на эти атрибуты. У нас есть данные; теперь пришло время добавить поведение к нашим классам.

Давайте смоделируем несколько действий для нашего класса `Point`. Мы начнем с метода, называемого `reset`, который перемещает точку в начало координат (начало координат — это точка, где `x` и `y` равны нулю). Это хорошее вводное действие, так как оно не требует параметров:

```python
class Point:
    def reset(self):
        self.x = 0
        self.y = 0

p = Point()
p.reset()
print(p.x, p.y)
```

Результат выполнения оператора `print` покажет два нуля для атрибутов:

```
0 0
```

> **Примечание:** В Python метод оформляется так же, как и функция. Он начинается с ключевого слова `def`, за которым следует пробел и имя метода. Затем идет пара круглых скобок, содержащих список параметров (мы обсудим параметр `self`, который иногда называют переменной экземпляра, чуть позже), и заканчивается двоеточием. Следующая строка с отступом содержит операторы внутри метода. Эти операторы могут быть произвольным Python-кодом, работающим с самим объектом и любыми переданными параметрами.

Мы пропустили подсказки типов в методе `reset()`, так как это не самое подходящее место для них. Мы обсудим оптимальные места для добавления подсказок типов в разделе *Инициализация объекта*. Сейчас давайте немного подробнее рассмотрим эти переменные экземпляра и то, как работает переменная `self`.

> **Примечание:** *self* — это первый параметр каждого метода в классе Python. Он ссылается на текущий экземпляр класса и позволяет методам объекта обращаться к атрибутам и другим методам этого экземпляра.


